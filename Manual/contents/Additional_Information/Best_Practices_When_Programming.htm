<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Лучшие практики при программировании</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains some best practices when programming using GameMaker Studio 2" />
  <meta name="rh-index-keywords" content="Best Practices When Programming" />
  <meta name="search-keywords" content="best practices" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Лучшие практики при программировании</h1>
  <p>На этой странице мы расскажем о некоторых &quot;лучших практиках&quot; при программировании игры, а также немного о внутреннем устройстве GameMaker <span class="notranslate">Studio 2.</span> Однако прежде чем продолжить, стоит отметить два очень важных момента.
    момента:</p>
  <ul class="colour">
    <li>Это <em>руководство</em>, а не все-все-все-определяющий-100%-совершенный метод написания вашей игры! Упомянутые здесь вещи, как правило, больше относятся к организационной и микро-оптимизации и должны быть включены в ваши навыки программирования, когда вы почувствуете себя комфортно в GML.
      когда вы почувствуете себя комфортно с <span class="notranslate">GML</span> и решите, что они уместны.</li>
    <li>Если ваша игра работает нормально и вас все устраивает, <em>не спешите все менять только для того, чтобы выжать несколько дополнительных FPS.</em> Вы должны найти баланс между читабельным, гибким и модульным кодом и временем и энергией.
      необходимыми для внесения изменений, а также общим выигрышем в конечном итоге. В общем, если ничего не сломалось, не чините, а то, что вы узнали здесь, сохраните для следующего проекта.</li>
  </ul>
  <p>Сказав это, давайте продолжим и рассмотрим некоторые общие советы по написанию хорошего <span class="notranslate">GML-кода</span>, которые вы можете применять в любое время...<br>
  </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Стиль программирования</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Когда дело доходит до написания кода, у каждого есть свой <em>стиль</em>. Стиль, в котором вы программируете, - это то, как вы расставляете скобки, как отступаете от строк, как объявляете и называете переменные и т.д., и это очень важно для того, чтобы ваш код был понятен и читаем
      для других людей (и для вашего будущего "я", когда вам придется вернуться к этому проекту после некоторого времени работы над чем-то другим).</p>
    <p class="dropspot">Существует много, много <a href="http://en.wikipedia.org/wiki/Programming_style">стилей программирования</a>, и некоторые могут утверждать, что их стиль является лучшим для использования, но правда в том, что практически любой стиль подходит, если вы <strong>последовательны </strong>при
      если вы последовательны в его использовании и <em>ясно </em>и <em>очевидно </em>, что все является и делает.</p>
    <p class="dropspot"><img alt="Code Style Example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractice_Style_Example.png">Приведенное выше изображение является примером объявления функции в сценарии для иллюстрации вышеизложенных моментов. Вы
      видите, что в нем используются комментарии в стиле JSDoc, чтобы четко объяснить, что все это делает, а стиль кодирования соответствует, с отступами в 4 пробела, подчеркиваниями, используемыми для локальных переменных, протоколируемым выводом и т.д...</p>
    <p class="dropspot">Также обратите внимание, что хотя редактор скриптов позволяет сворачивать код в каждой из открытых/закрытых скобок, вы можете использовать теги <span class="inline">#region</span> и <span class="inline">#endregion</span> для разделения частей вашего кода и значительного улучшения читабельности.
      особенно при работе с большими скриптами, содержащими множество функций. Регионы также можно комментировать - см. раздел "Редактирование" на этой странице руководства):</p>
    <p class="dropspot"><img alt="Example Of Using Regions" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractice_Regions.png">При написании кода следует помнить, что при компиляции готовой игры <span class="notranslate">GameMaker Studio 2</span> удаляет комментарии, убирает ненужные переносы строк, подставляет константные/простые/энумные значения и вообще сжимает код.
      комментарии, удаляет ненужные разрывы строк и пробелы, подставляет постоянные/макро/энум значения и вообще сжимает ваш код. Это означает, что вы можете добавлять столько пробелов вокруг вашего кода, сколько необходимо, и
      вам не нужно беспокоиться о том, чтобы комментарии были короткими или использовались редко.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Используйте локальные переменные</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Продолжая тему стиля программирования, можно сказать, что многие начинающие программисты стремятся впихнуть как можно больше в одну строку кода. Например:</p>
    <p class="code">draw_sprite(sprite_index, image_index, x + lengthdir_x(100, point_direction(x, y, mouse_x, mouse_y)), y + lengthdir_y(100, point_direction(x, y, mouse_x, mouse_y));</p>
    <p class="dropspot">Хотя он и не совсем нечитабелен, но неэффективен (например, функция <span class="inline">point_direction()</span> вызывается дважды), а также грязен и неудобен на вид. Гораздо лучше было бы выразить это как:</p>
    <p class="code">var p_dir = point_direction(x, y, mouse_x, mouse_y);<br> var local_x = x + lengthdir_x(100, p_dir);<br> var local_y = y + lengthdir_y(100, p_dir);<br> draw_sprite(sprite_index, image_index, local_x, local_y);</p>
    <p class="dropspot">Память и ресурсы, необходимые для создания этих локальных переменных, ничтожно малы, и их значительно перевешивает мгновенная польза, которую вы (или любой другой человек, читающий код позже) получите от его ясности. Та же идея должна быть применена и к функциям, где
      следует присваивать разумные имена входным переменным, использовать четкое форматирование и локальные переменные там, где это необходимо, чтобы сделать код максимально читабельным.</p>
    <p class="dropspot">Локальные переменные быстро обрабатываются в игре, поэтому используйте их по максимуму, а если выражение появляется в блоке кода или скрипте два или более раз, подумайте о создании локальной переменной для него. При использовании целей <a class="glossterm" data-glossterm="YoYo Compiler (YYC)" href="#"><span class="notranslate">YoYo</span></a> Compiler (YYC), если вы ссылаетесь на <span class="inline">global</span> или переменные экземпляра несколько раз в функции или блоке кода, особенно полезно присвоить их локальной переменной в начале кода.
      и затем ссылаться на эту локальную переменную, так как это обеспечит гораздо лучшую производительность.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Массивы</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><a href="../GameMaker_Language/GML_Overview/Arrays.htm">Массивы</a> быстры в использовании и требуют меньше памяти, чем структуры данных, но их можно еще больше оптимизировать. Когда вы создаете массив, память для него выделяется в зависимости от его размера, поэтому вы
      старайтесь сначала инициализировать массив до его максимального размера, даже если вы не планируете заполнять его в дальнейшем. Например, если вы знаете, что массив должен содержать максимум 100 значений, вы сразу инициализируете его до 100 слотов,
      используя <a href="../GameMaker_Language/GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a> функция:</p>
    <p class="code">array = array_create(100, 0);</p>
    <p class="dropspot">Это выделяет память для него одним &quot;куском&quot;, при этом все значения массива устанавливаются в значение 0 по умолчанию, и помогает поддерживать быструю работу, поскольку в противном случае каждый раз, когда вы добавляете новое значение в массив, вся память должна быть выделена заново.</p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Для цели HTML5 присвоение массивов подобным образом не применяется, и ваши массивы должны инициализироваться с 0 для этой цели! Вы можете легко справиться с этим, проверив переменную os_browser, например:</p>
    <p class="code"><span style="padding-left:1px;">if (os_browser == browser_not_a_browser)<br>
    {<br>
    array_create(100, 0);<br>
    }<br>
else<br>
    {<br>
    for (var i = 0; i &lt; 100; ++i;)<br>
        {<br>
        array[i] = 0;<br>
        }<br>
    }</span></p>
    <p class="dropspot">Вы также можете освободить память, связанную с массивом, установив используемую переменную равной 0. Таким образом, чтобы очистить массив из приведенного выше примера кода, достаточно использовать:</p>
    <p class="code">массив = 0;</p>
    <p class="dropspot">Также обратите внимание, что массивы <strong>передаются по ссылке</strong>, но при изменении будут копироваться целиком (такое поведение называется <strong>copy on write</strong>). Таким образом, если вы передаете массив в функцию, вы передаете <em>ссылку </em>на
      исходный массив, и любые значения, считанные из него, будут получены из исходного источника. Это хорошо и быстро, но если вам нужно изменить какие-либо значения массива, сам массив дублируется в момент записи, и все сделанные изменения <strong>должны быть возвращены из функции, иначе они будут потеряны</strong>.
      Это намного медленнее и потребляет больше памяти, поэтому будьте осторожны при использовании массивов в функциях.</p>
    <p class="dropspot">Однако вы можете избежать такого поведения при копировании при записи, используя специальный <a href="../GameMaker_Language/GML_Overview/Accessors.htm">аксессор</a> массива <span class="inline">@</span>, так как он дает прямой доступ к базовому массиву. Например:</p>
    <p class="code">// Вызываем функцию, передавая наш массив<br> my_function(my_array);
    </p>
    <p class="code">// Функция выглядит следующим образом:<br>
      <br> function my_function(_a)<br> {
      <br> // Массив будет скопирован и копия модифицирована,<br> // что потребует от вас использования &quot;return _a&quot;, позже<br> _a[0] = 100;<br> // Это изменит ОРИГИНАЛЬНЫЙ массив напрямую и<br> // не требует его возврата<br> _a[@0]
      = 100;<br> }
    </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Структуры данных</a></p>
  <div class="droptext" data-targetname="drop-down3">
    <p class="dropspot"> <a href="../GameMaker_Language/GML_Reference/Data_Structures/Data_Structures.htm">Структуры данных</a> в <span class="notranslate">GameMaker Studio 2</span> были оптимизированы и стали намного быстрее, чем в предыдущих версиях <span class="notranslate">GameMaker</span>. Их по-прежнему необходимо очищать (уничтожать), когда
      для освобождения памяти, и они все еще могут быть медленнее, чем, скажем, массивы, но простота использования и дополнительные функции для работы с данными, которые они содержат, часто перевешивают минимальную разницу в скорости, так что не бойтесь использовать их в ваших
      играх.
    </p>
    <p class="dropspot">Следует отметить, что из всех структур данных, DS Maps, в частности, отличаются высокой скоростью чтения и записи, что делает их отличным вариантом для всех типов задач.</p>
    <p class="dropspot">Ранее мы упоминали <a href="../GameMaker_Language/GML_Overview/Accessors.htm">аксессоры</a> для массивов, но они также доступны для структур данных, что может помочь очистить ваш код и сделать его намного легче для чтения.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">Столкновения</a></p>
  <div class="droptext" data-targetname="drop-down4">
    <p class="dropspot">В <span class="notranslate">GameMaker Studio 2</span> существует <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Collisions/Collisions.htm">множество способов борьбы с коллизиями</a>, и большинство из них сопровождается небольшими дополнительными нагрузками на процессор. Функции <span class="inline">collision_</span> и <span class="inline">point_</span>, <span class="inline">place_</span> и <span class="inline">instance_</span> - все они основаны на проверке <a class="glossterm" data-glossterm="ограничительная рамка" href="#">ограничивающих ра</a> мок у
      все экземпляры данного типа в комнате, и хотя в движок встроена некоторая оптимизация для ограничения этих проверок, столкновения никогда не являются наиболее эффективными. Если вы начнете использовать точные коллизии, производительность
      также заметно ухудшится, поскольку вы будете не только проверять граничные рамки, но и выполнять проверку на пиксель, что очень медленно. В техническом блоге <span class="notranslate">YoYo Games</span> это обсуждается здесь:</p>
    <ul class="dropspotlist">
      <li class="dropspot"><a href="https://www.yoyogames.com/blog/32/the-hazards-of-precise-collision-detection">Опасности точного обнаружения столкновений</a></li>
    </ul>
    <p class="dropspot">Это не означает, что вы не должны использовать эти функции, так как они могут быть очень удобными. Однако вы должны знать, какие из них использовать и когда, поскольку все они работают немного по-разному и имеют разную скорость. Примерное правило заключается в том, что
      функции <span class="inline">place_</span> работают быстрее, чем функции <span class="inline">instance_</span>, которые работают быстрее, чем функции <span class="inline">collision_</span> и <span class="inline">point_</span>, поэтому читайте страницы
      в руководстве по каждому из этих типов функций и убедитесь, что выбрали наиболее подходящую для каждой ситуации.</p>
    <p class="dropspot">В качестве альтернативы рассмотрите возможность создания<strong> системы столкновений на основе плитки</strong>, которая может быть создана с помощью <a href="../GameMaker_Language/GML_Reference/Asset_Management/Rooms/Tile_Map_Layers/Tile_Map_Layers.htm">функций tilemap</a> или даже
      пользовательского двумерного массива или сетки DS. Они будут очень быстрыми и помогут увеличить скорость вашей игры. Однако если вы используете нерегулярную местность или стены и объекты, которые не выравниваются по сетке, они могут не подойти. Вы можете найти очень простой
      учебник по столкновениям тайлмапов по следующей видеоссылке</p>
    <ul class="dropspotlist">
      <li class="dropspot"><a href="https://youtu.be/UyKdQQ3UR_0">Коллизии плиток в <span class="notranslate">GameMaker Studio 2</span></a></li>
    </ul>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down5" href="#">Замена текстур и партии вершин</a></p>
  <div class="droptext" data-targetname="drop-down5">
    <p class="dropspot">Если вы включите <a href="../GameMaker_Language/GML_Reference/Debugging/show_debug_overlay.htm"><strong>наложение отладки</strong></a>, вы увидите, что при тестировании в верхней части экрана отображаются две цифры в скобках. Первая - это количество
      выполняемых <strong>подмен текстур </strong>, а вторая - количество <strong>вершинных батчей</strong>. На эти цифры влияет множество факторов, и вам никогда не удастся свести их к (0) (0), поскольку движок требует выполнения одного или двух операций на каждом шаге.
      каждый шаг, но вы должны стремиться снизить эти значения как можно ниже.</p>
    <p class="dropspot"><img alt="The Debug Overlay Bar" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractices_DebugOverlay.png">Для замены текстур лучшим и наиболее эффективным способом является оптимизация того, как ваши спрайты и фоны
      хранятся на странице текстур. Это делается в <a href="../The_Asset_Editors/Sprites.htm">свойствах спрайта</a>, и вы можете создавать страницы текстур в <a href="../Settings/Texture_Groups.htm">редакторе групп текстур</a>. Если у вас есть несколько
      изображений, которые используются только в главном меню (например), то поместите их вместе на отдельную <a href="../Settings/Texture_Information/Texture_Pages.htm">страницу текстур</a>. То же самое, если у вас есть изображения, специфичные для уровня, или для игрока и врагов,
      и т.д. В общем, вы хотите сгруппировать их по использованию, чтобы максимально сократить количество подмен. Кроме того, для оптимизации <a class="glossterm" data-glossterm="VRAM" href="#">VRAM</a> вы можете использовать различные функции <a href="../GameMaker_Language/GML_Reference/Drawing/Textures/Textures.htm">prefetch и flush</a> для загрузки и удаления текстур из памяти по мере необходимости.</p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Как уже упоминалось в начале этой страницы, если ваша игра работает нормально с приличным FPS, то не стоит слишком беспокоиться о замене текстур... особенно при создании проектов на настольных мишенях. Эти оптимизации лучше всего подходят для
      при использовании в больших играх или на мобильных устройствах низкого класса, а при неправильном использовании они могут негативно повлиять на производительность.</p>
    <p class="dropspot">Информация о вершинах отправляется &quot;партиями&quot; на GPU для отрисовки, и в целом, чем больше партия, тем лучше. Поэтому при отрисовке следует избегать &quot;разбиения&quot; партии, так как это увеличит количество партий вершин, отправляемых в графический процессор.
      GPU. Существует ряд вещей, которые могут нарушить пакет, основными из них являются <strong>режимы наложения</strong>, установка <strong>цвета рисования</strong>, установка <strong>альфа-канала рисования</strong> и рисование с использованием встроенных форм и
      примитивы.
    </p>
    <p class="dropspot">Так, если у вас есть несколько экземпляров пули, которые рисуют, используя режим наложения <span class="inline">bm_add</span>, например, вы будете создавать новую партию вершин для каждой из них, что определенно плохо! Вместо этого у вас есть объект контроллера
      в вашей игре, который рисует все пули вместо этого, например, так:</p>
    <p class="code">gpu_set_blendmode(bm_add);<br> with (obj_BULLET)<br> {<br> draw_self();<br> } <br> gpu_set_blendmode(bm_normal);
    </p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Это относится не только к использованию bm_add <span class="inline" style="font-size: 14px">-</span> любое изменение смешивания нарушит пакет и приведет к снижению производительности.</p>
    <p class="dropspot">Таким образом, все пули будут нарисованы в одной партии. Этот метод может быть применен также к альфа и цвету рисования, и на самом деле разумное использование функций <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendenable.htm"><span class="inline">gpu_set_blendenable()</span></a>,
      <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestref.htm"><span class="inline">gpu_set_alphatestref()</span></a>, и <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestenable.htm"><span class="inline">gpu_set_alphatestenable()</span></a> может
      значительно повысить производительность и могут быть включены/выключены по мере необходимости в коде вашего проекта, хотя они могут не подходить для всех типов графики или проектов.</p>
    <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Если вам не требуется, чтобы экземпляр рисовал сам себя при использовании контроллера таким образом, вы можете просто добавить комментарий в событие Draw Event, чтобы подавить рисование по умолчанию, или сделать экземпляр невидимым (хотя это приведет к тому.
      хотя это предотвратит выполнение кода для экземпляра во всех событиях рисования).</p>
    <p class="dropspot">Другой способ уменьшить эти числа - отключить опцию <strong>Separate Texture Page</strong> для спрайтов, если это не является абсолютно необходимым. Каждое изображение, сохраненное таким образом, отправляется на свою собственную страницу текстур и по-разному сортируется, поэтому лучше иметь эти изображения
      на обычной текстурной странице лучше. Затем вы можете получить UVS-координаты с помощью функции <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> функция
      и сохранить их в переменных для последующего использования. Это может быть небольшое количество дополнительного кода, но эффект, который вы получите, того стоит. Обратите внимание, что этот метод не позволяет повторять текстуры!</p>
    <p class="dropspot">Как и в случае со всеми этими советами, если их изменение усложняет вашу жизнь, а игра работает нормально, не стоит слишком беспокоиться об этом...</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down6" href="#">Частицы</a></p>
  <div class="droptext" data-targetname="drop-down6">
    <p class="dropspot"><a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particles.htm">Частицы</a> предлагают очень быстрый и эффективный способ создания динамических эффектов в вашей игре, и в целом они обеспечивают хорошую производительность. Однако стоит отметить, что
      использование аддитивного смешивания, альфа-смешивания и смешивания цвета для частиц может снизить эту производительность, особенно на мобильных устройствах, поэтому если вам это не нужно, не используйте это! Аддитивное смешивание, в частности, может значительно увеличить вершинные
      и должны использоваться с осторожностью.</p>
    <p class="dropspot">Обратите внимание, что для HTML5, не поддерживающего WebGL, наличие разноцветных исчезающих частиц потребует большого количества кэширования изображений и будет очень медленным. Однако, поскольку спрайты частиц могут быть анимированными, вы можете создать анимированный спрайт, имеющий подизображения, которые
      меняют цвет, а затем использовать его для частицы. Это все равно будет выглядеть как постепенное изменение цвета, но не потребует постоянного создания кэш-изображений.</p>
    <p class="dropspot">Вы можете узнать больше о частицах на странице <a href="Guide_To_Using_Particles.htm">Руководство по использованию частиц</a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down7" href="#">Поверхности</a></p>
  <div class="droptext" data-targetname="drop-down7">
    <p class="dropspot">Наконец, мы вкратце коснемся использования <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/Surfaces.htm">поверхностей, поскольку</a> GameMaker <span class="notranslate">Studio 2 имеет</span> довольно значительную оптимизацию при их использовании в ваших играх: возможность
      включать и выключать <strong>буфер глубины</strong>.</p>
    <p class="dropspot">Когда вы просто используете поверхности, как обычно, GMS2 фактически создает поверхность и сопутствующий буфер глубины для обеспечения правильной сортировки глубины при рисовании чего-либо в 3D. Однако, для большинства 2D игр этот дополнительный буфер глубины просто не нужен и поэтому
      занимает дополнительное пространство памяти и время обработки, которое можно было бы использовать для других целей. Именно здесь и появляется функция <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_depth_disable.htm"><span class="inline">surface_depth_disable()</span></a> 
      в игру...</p>
    <p class="dropspot">Эту функцию можно вызвать перед созданием поверхности, чтобы отключить генерацию буфера глубины, и все поверхности, созданные после этого, не будут иметь созданного для них буфера глубины. Вы можете включать/выключать эту функцию по мере необходимости, и даже можете вызвать ее один раз в начале игры, чтобы отключить буфер глубины для всех поверхностей, созданных после этого.
      ее один раз в начале игры, чтобы отключить буферы глубины для всех последующих вызовов поверхностей (и в большинстве 2D-игр это нормально). Это не даст значительного прироста производительности, но это определенно то, что следует иметь в виду, если ваша игра в значительной степени полагается на
      и может остановить нехватку памяти на устройствах с низким уровнем производительности.</p>
  </div>
  <p> </p>
  <p>Помимо основных вещей, упомянутых выше, есть и другие, более общие вещи, которые могут помочь в производительности и которые также считаются &quot;хорошей практикой&quot;:</p>
  <ul class="colour">
    <li>не бойтесь использовать тригонометрические функции, поскольку (вопреки распространенному мнению) они довольно быстрые, особенно по сравнению с частицами, столкновениями, струнами и т.д....</li>
    <li>не помещайте в события Draw код, не предназначенный для рисования предметов</li>
    <li>использовать сигнал тревоги для вызова любого кода, который не нужно вызывать каждый шаг (вместо того, чтобы просто добавить это в событие Step)</li>
  </ul>
  <p>Но, как мы уже упоминали в начале страницы, все эти оптимизации необязательны, и если ваша игра прекрасно работает с 60 вершинными партиями, 80 сменами текстур, аддитивным блендингом и т.д., то не стоит слишком беспокоиться об этом! Просто помните об этих вещах
    при программировании вашей следующей игры...</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="Additional_Information.htm">Дополнительная информация</a></div>
        <div style="float:right">Следующее: <a href="The_File_System.htm">Файловая система</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Nest Practices
-->
  <!-- TAGS
best_practices
-->

</body></html>