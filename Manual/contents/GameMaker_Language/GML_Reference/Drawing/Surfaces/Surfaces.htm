<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Поверхности</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Reference section for the Surface functions and variables" />
  <meta name="rh-index-keywords" content="" />
  <meta name="search-keywords" content="Surfaces,application_surface,application surface,app surface" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Поверхности</h1>
  <p>В обычных событиях рисования <span class="notranslate">GameMaker Studio 2</span> не рисует непосредственно на экране, а рисует на <b>поверхности</b>, называемой <i>поверхностью приложения</i>. Эта поверхность, по сути, является чистым &quot;холстом&quot;, с которым можно манипулировать
    и в большинстве случаев <span class="notranslate">GameMaker Studio 2</span> делает это за вас (хотя вы также можете сами управлять ею в коде для создания <span class="notranslate">шейдеров</span>, масштабирования и многих других вещей - более подробная информация приведена ниже).</p>
  <p>Однако, помимо этой прикладной поверхности, вы также можете создавать свои собственные поверхности и использовать их для создания потрясающих или тонких спецэффектов в вашей игре. Например, можно использовать поверхности для &quot;ловли&quot; экземпляров, которые затем могут быть уничтожены,
    и таким образом можно создать эффект деколи, когда спрайт экземпляра отображается на поверхности, как будто он все еще существует, позволяя создавать графические эффекты, такие как обломки, кровь и т.д., без каких-либо реальных затрат на обработку. Еще одна вещь, которую можно
    использовать их как текстуры, которыми можно манипулировать, или создавать спрайты &quot;на лету&quot;, или создавать сложные наложения. на самом деле, возможности использования поверхностей безграничны!</p>
  <p>Нормальные поверхности довольно просты в использовании, но есть несколько основных правил, которые необходимо соблюдать при их использовании:</p>
  <ul class="colour">
    <li>Во-первых, вы должны понимать, что поверхности<i>(за исключением</i> поверхности приложения) являются &quot;непостоянными&quot;. Это означает, что если устройство или окно теряет фокус или сворачивается (хороший пример - когда вы переходите по ALT +Tab в другое окно и обратно в <span class="notranslate">Windows</span>,
      или на устройстве <span class="notranslate">Android</span>, когда приложение теряет фокус из-за вызова), то поверхность <strong>может быть уничто</strong>жена. Это происходит потому, что она хранится <em>только</em> в памяти текстур<a class="glossterm" data-glossterm="VRAM" href="#">(VRAM</a>) и
      и может быть перезаписана, когда целевой платформе понадобится эта память для чего-то другого. <i><b>всегда</b></i> иметь некоторый тип отказоустойчивого кода на месте, обычно с помощью <a href="surface_exists.htm"><tt>surface_exists()</tt></a>      функция.</li>
  </ul>
  <p class="note" style="padding-top: 0.5em;padding-right: 1em;padding-bottom: 0.5em;padding-left: 4em"><strong>ПРИМЕЧАНИЕ</strong>: Кажется, что этого не происходит со спрайтами или другими визуальными активами (но на самом деле происходит!), поскольку они также хранятся в обычной памяти (RAM), и когда они удаляются из текстурной памяти (VRAM), они немедленно восстанавливаются из
    обычной памяти, когда игра восстанавливает фокус.</p>
  <ul class="colour">
    <li>Во-вторых, следует учитывать, что поверхности могут требовать большого количества VRAM для использования, поэтому их следует стараться делать как можно меньше. Обычно их размер не должен превышать размер окна просмотра или дисплея.</li>
    <li>В-третьих, <b>поверхности</b> следует <b>создавать только в событии draw</b>. Если вы создадите поверхность в событии Create экземпляра, вы можете получить тот <i>же</i> индекс, что и у <tt>application_surface</tt>. Это может вызвать множество проблем
      и путаницу, поскольку вы думаете, что используете свою собственную поверхность, но на самом деле вы используете текущую цель рендеринга. Также всегда старайтесь ограничивать <i>рисование</i> на поверхности в событии draw, поскольку из-за оптимизированного способа, которым <span class="notranslate">GameMaker</span>
      Studio 2, рекомендуется держать все функции рисования <i>в событии</i> draw - это включает очистку поверхности при ее первом создании и т.д.. Рисование на поверхность вне события draw возможно и может быть
      даже необходимо для некоторых эффектов, но так делать не <em>следует</em>.</li>
    <li>В-четвертых, при рисовании на поверхности вручную поверхность <i>всегда</i> находится в позиции (0,0). Это означает, что вам может понадобиться преобразовать <em>абсолютные</em> координаты в <em>относительные</em> для поверхности. Например, если у вас есть
      поверхность размером с камеру и вы хотите нарисовать что-то, что в данный момент видно в камере, на этой поверхности, вы должны вычесть координаты x и y вида камеры из фактических координат x и y, чтобы получить относительную позицию относительно поверхности (0,0).
      позиция. Таким образом, код будет выглядеть примерно так:</li>
  </ul>
  <p class="code" style="margin-top: 0px;margin-right: 50px;margin-bottom: 0px;margin-left: 100px">if view_current = 0<br> {<br> surface_set_target(surf);
    <br> with (obj_Effect)<br> {
    <br> var _vx = camera_get_view_x(view_camera[1]);<br> var _vy = camera_get_view_y(view_camera[1]);<br> draw_sprite(sprite_index, image_index, x - _vx, y - _vy);<br> }
    <br> surface_reset_target();
    <br> }
    <br> else
    <br> {
    <br> draw_surface(surf, 0, 0);<br> }
  </p>
  <ul class="colour">
    <li>Наконец, стоит отметить, что при рисовании на поверхности будет учитываться цвет <em>и</em> альфа-компонент каждого пикселя, как самой поверхности, так и того, что на нее рисуется. Это может привести к довольно неинтуитивным
      результатам (например, при рисовании спрайта с альфа-составляющей 0,5 на поверхность с альфа-составляющей 0 получится итоговая альфа-составляющая 0,25). Причины этого объясняются на следующей странице, и мы рекомендуем вам прочитать ее перед началом работы с поверхностями: <a href="../../../../Additional_Information/Guide_To_Using_Blendmodes.htm">Руководство по использованию блендмодов</a></li>
  </ul>
  <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: Это не относится к поверхности приложения, только к поверхностям, созданным пользователем.</p>
  <p>Основное использование поверхности может быть следующим:</p>
  <ul class="colour">
    <li>Сначала вы создаете поверхность и присваиваете ее индекс переменной.</li>
    <li>В этом случае цель рисования будет задана на поверхности, а не на дисплее.</li>
    <li>Далее вы рисуете то, что хотите, а также выполняете любые другие манипуляции.</li>
    <li>После завершения работы вы сбрасываете цель рисования, чтобы все дальнейшее рисование снова происходило на экране.</li>
    <li>Наконец, вы нарисуете поверхность (или используете ее в <span class="notranslate">шейдере</span>, или что-то еще).</li>
  </ul>
  <p>Следует отметить, что если вам нужно перерисовать весь дисплей на поверхность (включая плитки, фон и т.д.), вы можете просто обратиться к самой поверхности приложения (подробнее см. ниже) или назначить поверхность порту представления
    используя переменную <a href="../../Cameras_And_Display/Cameras_And_Viewports/view_surface_id.htm"><tt>view_surface_id[0..7]</tt></a> в этом случае все, что видно в данном порту представления, будет отрисовано на соответствующей поверхности.</p>
  <p>Для работы с поверхностями существуют следующие функции (эти функции предназначены для создания и манипулирования поверхностями, но чтобы нарисовать их на экране, необходимо использовать специальные функции рисования, которые можно найти ниже):</p>
  <p> </p>
  <ul class="colour">
    <li><a href="surface_exists.htm">поверхность_существует</a></li>
    <li><a href="surface_create.htm">поверхность_создать</a></li>
    <li><a href="surface_create_ext.htm">поверхность_создать_экст</a></li>
    <li><a href="surface_resize.htm">размер_поверхности</a></li>
    <li><a href="surface_set_target.htm">поверхность_задать_цель</a></li>
    <li><a href="surface_set_target_ext.htm">surface_set_target_ext</a></li>
    <li><a href="surface_get_target.htm">surface_get_target</a></li>
    <li><a href="surface_get_target_ext.htm">surface_get_target_ext</a></li>
    <li><a href="surface_reset_target.htm">поверхность_сброса_цели</a></li>
    <li><a href="surface_copy.htm">поверхностное_копирование</a></li>
    <li><a href="surface_copy_part.htm">поверхность_копирования_части</a></li>
    <li><a href="surface_depth_disable.htm">глубина_поверхности_запрещена</a></li>
    <li><a href="surface_get_height.htm">surface_get_height</a></li>
    <li><a href="surface_get_width.htm">surface_get_width</a></li>
    <li><a href="surface_get_texture.htm">поверхность_get_текстура</a></li>
    <li><a href="surface_get_depth_disable.htm">surface_get_depth_disable</a></li>
    <li><a href="surface_getpixel.htm">поверхность_getpixel</a></li>
    <li><a href="surface_getpixel_ext.htm">surface_getpixel_ext</a></li>
    <li><a href="surface_free.htm">поверхность_свободная</a></li>
    <li><a href="surface_save.htm">поверхность_сохранения</a></li>
    <li><a href="surface_save_part.htm">поверхность_сохранить_часть</a></li>
  </ul>
  <p> </p>
  <p>Для рисования поверхностей существуют следующие функции:</p>
  <p class="note"><b>ПРИМЕЧАНИЕ: </b>При работе с поверхностями существует вероятность того, что они могут прекратить свое существование в любой момент, поскольку хранятся в памяти текстуры. Вы должны <b>ВСЕГДА</b> проверять существование поверхности с помощью функции <span style="font-size:1px;"><a href="surface_exists.htm"><tt style="font-size: 14px">surface_exists()</tt></a></span> перед тем, как
    обращаться к ней напрямую.</p>
  <p> </p>
  <ul class="colour">
    <li><a href="draw_surface.htm">нарисовать_поверхность</a></li>
    <li><a href="draw_surface_ext.htm">нарисовать_поверхность_экст</a></li>
    <li><a href="draw_surface_part.htm">нарисовать_поверхность_части</a></li>
    <li><a href="draw_surface_part_ext.htm">нарисовать_поверхность_части_экст</a></li>
    <li><a href="draw_surface_stretched.htm">нарисовать_поверхность_растянутой</a></li>
    <li><a href="draw_surface_stretched_ext.htm">draw_surface_stretched_ext</a></li>
    <li><a href="draw_surface_tiled.htm">нарисовать_поверхность_плиткой</a></li>
    <li><a href="draw_surface_tiled_ext.htm">draw_surface_tiled_ext</a></li>
    <li><a href="draw_surface_general.htm">рисовать_поверхность_общая</a></li>
  </ul>
  <p> </p>
  <p>Наконец, у вас есть две функции для хранения и извлечения поверхностей в <a href="../../Buffers/Buffers.htm">буферах</a>:</p>
  <p> </p>
  <ul class="colour">
    <li><a href="../../Buffers/buffer_get_surface.htm">buffer_get_surface</a></li>
    <li><a href="../../Buffers/buffer_set_surface.htm">buffer_set_surface</a></li>
  </ul>
  <p> </p>
  <p>Как упоминалось выше, в <span class="notranslate">GameMaker Studio 2</span> большинство вещей не выводится на экран напрямую, вместо этого они выводятся на <b>поверхность приложения</b>. Это, по сути, поверхность - такая же, как и любая другая, которую вы можете создать самостоятельно с помощью функций
    surface functions - и как таковой, ею можно манипулировать, рисовать на ней, посылать <span class="notranslate">шейдерам</span> и т.д.. В принципе, все, что вы обычно делаете с созданной вами поверхностью, можно применить и к поверхности приложения.</p>
  <p class="note"><b>ПРИМЕЧАНИЕ</b>: Единственное, что вы <b>не можете</b> сделать с поверхностью приложения, - это освободить ее. Она всегда существует, хотя значение индекса для доступа к ней может меняться.</p>
  <p>Когда вы запускаете свою игру, эта поверхность создается при первом вызове <a href="../../../../The_Asset_Editors/Object_Properties/Draw_Events.htm">события draw</a> в каждой новой комнате, в которую вы входите, что означает, что до этого момента ничего не рисуется.
    момента. Однако вы все равно можете получить положение поверхности приложения и изменить ее размер в <b>событии Create</b> или любом другом событии без каких-либо ошибок, а используемые значения будут относиться к поверхности в момент ее создания. Фактическая последовательность
    событий для создания и рисования поверхности приложения выглядит следующим образом:</p>
  <ul class="colour">
    <li>Событие перед отрисовкой<br> --- &gt; <b>создается поверхность приложения (если она не существует) и устанавливается цель отрисовки</b>.</li>
    <li><b></b>Для каждого видимого порта просмотра или, если ни один порт просмотра не активен, один раз.
      <ul class="colour">
        <li>Событие начала рисования</li>
        <li>событие рисования</li>
        <li>Событие окончания рисования<br> --- &gt; <b>здесь происходит сброс цели рендеринга поверхности приложения</b></li>
      </ul>
    </li>
    <li><b></b>Post draw event<br> --- &gt; <b>теперь поверхность приложения по умолчанию рисуется в <a class="glossterm" data-glossterm="буфер дисплея" href="#">буфер дисплея</a><br><a class="glossterm" data-glossterm="буфер дисплея" href="#"></a> </b>. 
	                 (хотя вы можете отключить это с помощью <span class="inline"><a href="application_surface_draw_enable.htm">application_surface_draw_enable()</a></span>)</li>
    <li><b></b>Событие начала рисования графического интерфейса пользователя</li>
    <li>Событие рисования графического интерфейса</li>
    <li>Событие окончания рисования графического интерфейса</li>
  </ul>
  <p>Использование этой поверхности означает, что вы можете легко создавать невероятные переходы с помощью <span class="notranslate">шейдеров</span>, или взять экран и обернуть его вокруг 3D-формы, или просто масштабировать игру с низким разрешением до экрана любого разрешения... Возможности безграничны!</p>
  <p>Чтобы получить доступ к этой поверхности, необходимо использовать встроенную глобальную переменную <tt>application_surface</tt>, которая описана на следующей странице:</p>
  <p> </p>
  <ul class="colour">
    <li><a href="application_surface.htm">поверхность_приложения</a></li>
  </ul>
  <p> </p>
  <p>У вас также есть несколько специализированных функций, предназначенных <em>только </em>для работы с поверхностью приложения:</p>
  <p> </p>
  <ul class="colour">
    <li><a href="application_surface_enable.htm">приложение_поверхность_включено</a></li>
    <li><a href="application_surface_is_enabled.htm">приложение_поверхность_является_включенным</a></li>
    <li><a href="application_get_position.htm">application_get_position</a></li>
    <li><a href="application_surface_draw_enable.htm">application_surface_draw_enable</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="../Drawing.htm">Рисунок</a></div>
        <div style="float:right">Следующее: <a href="../Lighting/Lighting.htm">Освещение</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Surfaces
app surface
application surface
-->
  <!-- TAGS
surfaces_functions
-->

</body></html>