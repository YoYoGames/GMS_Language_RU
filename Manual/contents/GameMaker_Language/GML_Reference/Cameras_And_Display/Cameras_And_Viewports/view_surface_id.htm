<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>view_surface_id</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Reference page for view_surface_id" />
  <meta name="rh-index-keywords" content="view_surface_id" />
  <meta name="search-keywords" content="view_surface_id" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>view_surface_id</h1>
  <p>С помощью этой переменной можно установить содержимое данного порта просмотра для рисования на поверхности или получить идентификатор текущей поверхности, если она была назначена порту просмотра. При работе с поверхностями часто требуется, чтобы вы захватили <i>всю</i> видимую
    область экрана на поверхность, и поэтому вы назначаете ее порту представления с помощью этой переменной. Это означает, что все, что отображается в выбранном представлении, теперь будет рисоваться на назначенной поверхности. Теперь вид <i>не</i> будет рисоваться на
    экран, что означает, что вам нужно будет либо:</p>
  <ul class="colour">
    <li>Включите новый вид и рисуйте поверхность только в этом виде (используя <a href="view_current.htm"><tt>вид_текущий</tt></a> для проверки того, какой вид рисуется)</li>
    <li>Нарисуйте поверхность в событии Draw GUI экземпляра, поскольку слой GUI не зависит от представлений.</li>
  </ul>
  <p>Вы также можете прочитать эту переменную, чтобы получить индекс поверхности, которая была назначена выбранному виду, или она вернет -1, если поверхность не была назначена, и обычно поверхность, используемая для этой функции, должна быть размером самой камеры вида
    (не порта вида). В расширенном примере ниже показана базовая настройка для захвата вида и его отрисовки в событии <b>Draw GUI</b>, а для получения дополнительной информации о поверхностях см. раздел " <a href="../../Drawing/Surfaces/Surfaces.htm">Поверхности"</a>.</p>
  <p>Обратите внимание, что вы также можете установить порт представления на поверхность с помощью функции <a href="view_set_surface_id.htm"><tt>view_set_surface_id()</tt></a>.</p>
  <p> </p>
  <h4>Синтаксис:</h4>
  <p class="code">view_surface_id[0...7];</p>
  <p> </p>
  <h4>Возвращается:</h4>
  <p class="code">Real (индекс поверхности или -1, если поверхность не была назначена)</p>
  <p> </p>
  <h4>Расширенный пример:</h4>
  <p>В этом расширенном примере мы создадим поверхность и назначим ее порту view port[0], чтобы она захватывала вид камеры, назначенный этому порту, а затем нарисуем ее на экране в событии Draw GUI. Для начала нам нужно инициализировать нашу переменную surface в событии
   <b>Create Event</b> экземпляра контроллера:</p>
  <p class="code">surf = -1;</p>
  <p>Мы установили переменную surface в -1, так как все функции surface должны использоваться в событиях <b>Draw</b>, чтобы предотвратить странные ошибки или неопределенное поведение. Итак, после этого в главном событии <b>Draw</b> мы получим следующее:</p>
  <p class="code">if !surface_exists(surf)<br> {
    <br> surf = surface_create(camera_get_view_width(view_camera[0]), camera_get_view_height(view_camera[0]));<br> view_surface_id[0] = surf;<br> }
  </p>
  <p>Поверхности <i>непостоянны</i>, то есть они могут быть удалены из памяти в любой момент из-за управления памятью ОС и других вещей, поэтому здесь мы проверяем, существует ли наша поверхность, и если нет, то создаем ее и присваиваем виду 0.
    Теперь все, что будет отображаться в представлении 0, будет рисоваться на созданной нами поверхности. Если вы ничего не сделаете в этот момент, то при запуске игры вы получите пустой экран, так как все рисование происходит на поверхности,
    но сама поверхность нигде не рисуется. Поэтому теперь нам нужно нарисовать поверхность на экране в событии <b>Draw GUI</b> следующим образом:</p>
  <p class="code">if surface_exists(surf)<br> {
    <br> draw_surface_stretched(surf, 0, 0, display_get_gui_width(), display_get_gui_height());<br> }
  </p>
  <p>Теперь этот код нарисует поверхность, которую мы создали из растянутой камеры обзора, чтобы заполнить весь слой GUI.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="Cameras_And_View_Ports.htm">Камеры и порты для просмотра</a></div>
        <div style="float:right">Далее: <a href="view_get_camera.htm">view_get_camera</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
view_surface_id
-->
  <!-- TAGS
view_surface_id
-->
</body>
</html>