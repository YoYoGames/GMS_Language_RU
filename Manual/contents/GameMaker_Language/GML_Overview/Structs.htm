<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Структуры и конструкторы</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Gurpreet S. Matharoo" />
  <meta name="topic-comment" content="Page outlining the use of Structs" />
  <meta name="rh-index-keywords" content="Structs" />
  <meta name="search-keywords" content="structs,new,delete,struct" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Структуры и конструкторы</h1>
  <p> <strong>Структура </strong>- это, проще говоря, переменная, которая содержит коллекцию других переменных. Переменные, которые хранит struct, могут быть любого <a href="Data_Types.htm">типа данных</a>, упомянутого ранее, и эти переменные можно читать из struct и записывать в struct после первоначального объявления struct.
    и записывать в них после первоначального объявления struct, а также можно добавлять дополнительные переменные в struct после ее объявления. Переменные, используемые в struct, должны соответствовать традиционным схемам именования, т.е. они не могут начинаться с цифр и должны состоять только из букв.
    состоять только из буквенно-цифровых символов и символа подчеркивания &quot;_&quot;, а также обратите внимание, что содержимое структуры <em>не зависит от экземпляра или функции, которая ее создала, и</em> поэтому вы можете - при желании - использовать встроенные имена переменных, такие как image_index.
    имена переменных, такие как <tt>image_index</tt> или <tt>x</tt> и <tt>y</tt>.</p>
  <p>После первоначального создания структуры не требуют никаких затрат на обработку, пока они существуют, хотя <i>и</i> занимают место в памяти. Синтаксис struct выглядит следующим образом:</p>
  <p class="code"><i>&lt;переменная&gt; =</i><br> {
   <br>
       <i> &lt;переменная&gt; : &lt;значение&gt;</i> <i>,</i><br>
       <i> &lt;переменная&gt; : &lt;значение&gt;</i> <i>,</i><br> <i></i> и т.д....
    <br> };
  </p>
  <p>Так, примером этого на практике может быть:</p>
  <p class="code">mystruct =<br> {
    <br> a : 20,<br> b : &quot;Hello World&quot;<br> };
  </p>
  <p>Приведенный выше код создает структуру в переменной <tt>mystruct</tt> в масштабе экземпляра и заполняет ее некоторыми значениями (структуры могут быть созданы в локальном, экземпляровом и глобальном масштабах, как и любые другие переменные - более подробную информацию см. в разделе " <a href="Variables_And_Variable_Scope.htm">Переменные и масштабы переменных</a> "). Обратите внимание, что вам не обязательно заполнять содержимое структуры при ее первоначальном создании, и вы можете создать пустую структуру, просто сделав это:</p>
  <p class="code">mystruct = {};</p>
  <p>Этот struct может быть добавлен позднее в код игры. Вот пример структуры с различными переменными и типами данных:</p>
  <p class="code">var _xx = 100;<br> mystruct =<br> {
    <br> a : 10,<br> b : &quot;Hello World&quot;,<br> c : int64(5),<br> d : _xx + 50,<br> e : function(a, b)<br> {
    <br> return a + b;<br> },
    <br> f : [ 10, 20, 30, 40, 50 ],<br> g : image_index<br> };
  </p>
  <p>В приведенном выше коде вы заметите, что в структурах можно определять методы и использовать функции времени выполнения, а также использовать локальные переменные и переменные экземпляра в объявлении структуры.</p>
  <p>Например, в приведенном выше примере вы заметите, что переменная struct &quot;g&quot; устанавливается в значение <span class="inline">image_index</span>, которое является переменной экземпляра. Вы можете подумать, что в этом случае вам нужно использовать ключевое слово <span class="inline">other</span>, чтобы получить переменную экземпляра, но это не обязательно. По сути, когда вы определяете struct<strong>, все переменные-члены, расположенные слева от двоеточия &quot;:&quot;, являются <em>переменными</em></strong> struct, а значения и переменные, расположенные справа, используют область видимости того, что определяет struct (в данном случае, экземпляра).</p>
  <p>Давайте рассмотрим простой пример, чтобы проиллюстрировать это. Допустим, вы хотите определить структуру с переменными &quot;x&quot; и &quot;y&quot; и хотите установить их на &quot;x&quot; и &quot;y&quot; экземпляра, определяющего структуру. На практике
    код будет выглядеть следующим образом:</p>
  <p class="code">mystruct =<br> {
    <br> x : x,<br> y : y<br> };
  </p>
  <p>В приведенном выше коде переменные-члены struct <tt>x</tt> и <tt>y</tt> устанавливаются в значения, хранящиеся в переменных экземпляра <tt>x</tt> и <tt>y</tt>, так как правая часть двоеточия &quot;:&quot; относится к экземпляру, определяющему
    структуру. Стоит отметить, что это означает, что вы <em>не можете</em> использовать переменные-члены struct для определения последующих переменных внутри объявления struct. Например, в следующем случае вы получите ошибку:</p>
  <p class="code">mystruct =<br> {
    <br> a : 10,<br> b : 10,<br> c : a + b<br> }
  </p>
  <p>Ошибка возникает потому, что переменные <tt>a</tt> и <tt>b</tt> на самом деле оцениваются в области видимости того, что определяет структуру (они находятся справа от двоеточия &quot;:&quot;), а не определяются внутри
    в самой структуре.<strong></strong></p>
  <h3 style="padding-left: 20px"><em><strong style="margin-left: 0px">ВАЖНО!</strong></em>  Вы <strong>не можете </strong>использовать какие-либо встроенные <em><strong>глобальный </strong></em>переменные области видимости в качестве имен членов структуры, например: <span class="inline">game_id</span> или <span class="inline">fps</span>.
    Полный список этих глобальных переменных вы можете найти на следующей странице:</h3>
  <ul class="colour">
    <li><a href="Struct_Forbidden_Variables.htm">Структура Запрещенные переменные</a></li>
  </ul>
  <p>После того, как структура определена, вы можете получить доступ к данным в ней, используя нотацию &quot;точка&quot;, как показано ниже:</p>
  <p class="code">mystruct =<br> {
    <br> a : 20,<br> b : &quot;Hello World&quot;<br> }
    <br>
    <br> mystring = mystruct.b + string(mystruct.a);</p>
  <p>Вы также можете выполнять операции над переменными внутри struct или использовать их в функциях, как и любые другие переменные. Например:</p>
  <p class="code">mystruct.a += 1;<br> mystruct.b = mystruct.a + 20;<br> mydir = point_direction(mouse_x, mouse_y, mystruct.xx, mystruct.yy);</p>
  <p>Наконец, структуры могут иметь другие структуры, вложенные в них, например, так:</p>
  <p class="code">mystruct =<br> {
    <br> a :<br> {<br> aa : &quot;Это пример&quot;<br> },
    <br> b :<br> {<br> bb : &quot;И еще один&quot;<br> },
    <br> };
  </p>
  <p>Для доступа к таким вложенным структурам по-прежнему используется точечная нотация, например, так:</p>
  <p class="code">var _str = mystuct.a.aa + &quot; &quot; + mystruct.b.bb;<br> show_debug_message(_str);
  </p>
  <p>Другим способом доступа к данным в структуре является использование функции <a href="Language_Features/with.htm"><span class="inline">with()</span></a> функцию. Так, например, вы можете сделать следующее:</p>
  <p class="code">with(mystruct)<br> {
    <br> a += other.x;<br> }
  </p>
  <p>Использование <span class="inline">with()</span> изменяет область видимости кода на данную структуру, где вы можете манипулировать переменными-членами в области видимости структуры. Обратите внимание, что в примере мы также используем <a href="Instance_Keywords.htm">ключевое слово<span class="inline">other</span> </a>.
    Это работает так же, как и в экземпляре при использовании <span class="inline">with()</span>, и будет ссылаться на экземпляр (или struct), который фактически выполняет блок кода.</p>
  <p>Когда структура больше не нужна, она может быть удалена из памяти с помощью оператора <a href="Language_Features/delete.htm"><tt>delete</tt></a> оператор, который помечает, что структура может быть собрана. Это не является строго обязательным, поскольку <a class="glossterm" data-glossterm="сборщик мусора" href="#">сборщик мусора</a> может сделать это автоматически, если структура больше не упоминается в вашем коде, но это хорошая практика, и мы рекомендуем это делать (например, вызвать <tt>delete</tt> в <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">событии Clean Up</a> экземпляра, чтобы явно сообщить сборщику мусора, что структура в области видимости экземпляра должна быть удалена). Вот пример:</p>
  <p class="code">// Создаем событие<br> mystruct =<br> {
    <br> pos_x : x,<br> pos_y : y,<br> count : 1000<br> };
    <br>
    <br> // Очистка события<br> delete mystruct;</p>
  <h2>Функции конструктора</h2>
  <p>Вы также можете использовать <a href="Script_Functions.htm">функции</a> или <a href="Method_Variables.htm">методы</a> <a href="Script_Functions.htm">скрипта</a> для создания функций, которые могут быть использованы для создания новых структур, что требует использования ключевого слова <tt>constructor</tt> для функции
    и оператора <a href="Language_Features/new.htm"><tt>новый</tt></a> при создании структуры из такой функции. См. следующую функцию:</p>
  <p class="code">function Vector2(_x, _y) <strong>constructor</strong><br> {
    <br> x = _x;<br> y = _y;<br>
    <br> static Add = function(_vec2)<br> {
    <br> x += _vec2.x;<br> y += _vec2.y;<br> }
    <br> }
  </p>
  <p>Или, используя синтаксис переменной метода:</p>
  <p class="code">Vector2 = function(_x, _y) constructor<br> {
    <br> x = _x;<br> y = _y;<br>
    <br> static Add = function(_vec2)<br> {
    <br> x += _vec2.x;<br> y += _vec2.y;<br> }
    <br> }
  </p>
  <p>Здесь мы создаем функцию под названием <tt>Vector2</tt> и сообщаем <span class="notranslate">GameMaker Studio 2</span>, что это функция, используемая для создания структур, добавляя ключевое слово <tt>constructor</tt> после ее определения. Затем вы можете вызвать эту функцию-конструктор следующим образом
    this:</p>
  <p class="code">v2 = new Vector2(10, 10);</p>
  <p>Теперь переменная <tt>v2</tt> будет содержать struct с переменными <tt>x</tt> и <tt>y</tt> и <a href="Functions/Static_Variables.htm">статическую</a> <a href="Method_Variables.htm">переменную метода</a> <tt>Add</tt>.</p>
  <p>Вы также можете использовать необязательные аргументы в функциях конструктора:</p>
  <p class="code">function Vector2<strong>(_x = 0, _y = 0</strong>) constructor<br> {
    <br> x = _x;<br> y = _y;<br> }
  </p>
  <p>Теперь этот конструктор будет использовать <tt>0</tt> для аргументов <tt>_x</tt> и <tt>_y</tt>, если они не указаны при вызове функции. Это означает, что вы можете создать новую структуру <tt>Vector2</tt> без необходимости указывать какие-либо аргументы:</p>
  <p class="code">empty_vector = new Vector2();</p>
  <h2>Наследование</h2>
  <p>Функции, созданные таким образом, также будут поддерживать одиночное <b>наследование</b>, то есть: вы можете создать функцию-конструктор, которая наследует данные от другой функции-конструктора.</p>
  <p class="note"><strong>ПРИМЕЧАНИЕ</strong>: При работе с наследованием вы не можете использовать переменные метода для определения функции конструктора, только функции сценария.</p>
  <p>Например, выше мы создали функцию-конструктор <tt>Vector2</tt>, поэтому мы можем использовать ее в качестве &quot;родителя&quot; для другой функции-конструктора, которую мы назовем Vector3:</p>
  <p class="code">function <strong>Vector3(_x, _y, _z) </strong><strong>:</strong><strong> Vector2(_x, _y) </strong>constructor<br> {
    <br> z = _z;<br>
    <br> static Add = function( _vec3 )<br> {
    <br> x += _vec3.x;<br> y += _vec3.y;<br> z += _vec3.z;<br> }
    <br> }
  </p>
  <p>Как вы видите, при определении функции мы используем двоеточие &quot;<span class="inline">:</span>&quot;, чтобы отделить новый конструктор от родительского конструктора, от которого он наследуется. Дочерний конструктор<tt>(Vector3</tt>) передает аргументы <tt>_x</tt> и
   <tt>_y</tt> аргументы в родительский конструктор<tt>(Vector2</tt>), которые используются для запуска сначала родительского конструктора, после чего выполняется дочерний конструктор. Таким образом, дочерний конструктор получает родительские переменные (x и y), а также может определять свои собственные (z).</p>
  <p>Вы также можете передавать постоянные значения в родительский конструктор, чтобы определенный дочерний конструктор всегда предоставлял одни и те же значения своему родительскому конструктору:</p>
  <p class="code">function Item(damage) constructor<br> {
    <br> my_damage = damage;<br> }
    <br>
    <br> function BasicSword() : Item(10) constructor<br> {}
    <br>
    <br> var _basic_sword = new BasicSword();<br> show_debug_message(_basic_sword.my_damage); // Выводит 10</p>
  <p>Это означает, что урон базового меча всегда будет равен <tt>10</tt>, так как он передает это значение своему родительскому конструктору независимо от того, какими могут быть его собственные аргументы.</p>
  <p>Обратите внимание, что присвоение значения по умолчанию аргументу в дочернем конструкторе отменяет значение по умолчанию для этого аргумента в родительском. Смотрите следующий пример:</p>
  <p class="code">function Parent(value = 10) constructor<br> {
    <br> show_debug_message(value);<br> }
    <br>
    <br> function Child(value = 20) : Parent(value) constructor<br> {
    <br> show_debug_message(value);<br> }
    <br>
    <br> var _child = new Child();</p>
  <p>Оба этих конструктора выведут <tt>20</tt> в выходной журнал, поскольку это значение по умолчанию для аргумента, установленного дочерним конструктором, и это же значение было передано в родительский конструктор.</p>
  <p>Более подробную информацию о <tt>новых</tt> и <tt>удаленных</tt> операторах см. на следующих страницах:</p>
  <ul class="colour">
    <li><a href="Language_Features/new.htm"><tt>новый</tt></a></li>
    <li><tt><a href="Language_Features/delete.htm"><tt>удалить</tt></a>
      </tt>
    </li>
  </ul>
  <h2>Строковый вывод</h2>
  <p>И последнее, что следует упомянуть о структурах, это то, что вы можете изменить то, что выводится на консоль из них для отладки. По умолчанию вызов функции <a href="../GML_Reference/Debugging/show_debug_overlay.htm"><span class="inline">show_debug_message()</span></a> на
    struct выводит содержимое struct (как показано выше). Однако можно настроить это сообщение, добавив в struct специально названный метод <span class="inline">toString</span>:</p>
  <p class="code">mystruct =<br> {
    <br> a : 20,<br> b : &quot;Hello World&quot;,<br>
    <br> toString : function()<br> {<br> return &quot;This stuct says &quot; + b + &quot;, &quot; + string(a) + &quot; times!&quot;;<br> } <br> }
    <br> show_debug_message(mystruct);
  </p>
  <p>Теперь, когда вызывается функция <span class="inline">show_debug_message()</span>, для генерации вывода будет использоваться метод <span class="inline">toString</span>, и - в приведенном выше примере - вы получите:</p>
  <p class="code">Эта структура говорит Hello World 20 раз!</p>
  <p>Обратите внимание, что вы также можете вызвать <a href="../GML_Reference/Strings/Strings.htm"><span class="inline">string()</span></a> функцию по ссылке на struct и использовать ее для вывода содержимого - или метода <span class="inline">toString</span> - на экран.
    экрана, или сохранить его в файл, или что угодно, например:</p>
  <p class="code">var _str = string(mystruct);<br> draw_text(32, 32, _str);</p>
  <p>Наконец, существует ряд функций <span class="notranslate">времени выполнения</span>, которые вы можете использовать для структур, чтобы получить переменные, которые они содержат, а также несколько других вещей. Вы можете найти их в следующем разделе:</p>
  <ul class="colour">
    <li><a href="../GML_Reference/Variable_Functions/Variable_Functions.htm">Переменные функции</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Назад: <a href="GML_Overview.htm">Обзор<span class="notranslate">GML</span></a></div>
        <div style="float:right">Следующее: <a href="Language_Features.htm">Особенности языка</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Все права защищены</span></h5>
  </div>
  <!-- KEYWORDS
Structs
struct
constructor
-->
  <!-- TAGS
structs
-->

</body></html>