
  
  Поверхности
  В обычных событиях рисования GameMaker Studio 2 не рисует непосредственно на экране, а рисует на поверхности, называемой поверхностью приложения. Эта поверхность, по сути, является чистым "холстом", с которым можно манипулировать
    и в большинстве случаев GameMaker Studio 2 делает это за вас (хотя вы также можете сами управлять ею в коде для создания шейдеров, масштабирования и многих других вещей - более подробная информация приведена ниже).
  Однако, помимо этой прикладной поверхности, вы также можете создавать свои собственные поверхности и использовать их для создания потрясающих или тонких спецэффектов в вашей игре. Например, можно использовать поверхности для "ловли" экземпляров, которые затем могут быть уничтожены,
    и таким образом можно создать эффект деколи, когда спрайт экземпляра отображается на поверхности, как будто он все еще существует, позволяя создавать графические эффекты, такие как обломки, кровь и т.д., без каких-либо реальных затрат на обработку. Еще одна вещь, которую можно
    использовать их как текстуры, которыми можно манипулировать, или создавать спрайты "на лету", или создавать сложные наложения. на самом деле, возможности использования поверхностей безграничны!
  Нормальные поверхности довольно просты в использовании, но есть несколько основных правил, которые необходимо соблюдать при их использовании:
  
    Во-первых, вы должны понимать, что поверхности(за исключением поверхности приложения) являются "непостоянными". Это означает, что если устройство или окно теряет фокус или сворачивается (хороший пример - когда вы переходите по ALT +Tab в другое окно и обратно в Windows,
      или на устройстве Android, когда приложение теряет фокус из-за вызова), то поверхность может быть уничтожена. Это происходит потому, что она хранится только в памяти текстур(VRAM) и
      и может быть перезаписана, когда целевой платформе понадобится эта память для чего-то другого. всегда иметь некоторый тип отказоустойчивого кода на месте, обычно с помощью surface_exists()      функция.
  
  ПРИМЕЧАНИЕ: Кажется, что этого не происходит со спрайтами или другими визуальными активами (но на самом деле происходит!), поскольку они также хранятся в обычной памяти (RAM), и когда они удаляются из текстурной памяти (VRAM), они немедленно восстанавливаются из
    обычной памяти, когда игра восстанавливает фокус.
  
    Во-вторых, следует учитывать, что поверхности могут требовать большого количества VRAM для использования, поэтому их следует стараться делать как можно меньше. Обычно их размер не должен превышать размер окна просмотра или дисплея.
    В-третьих, поверхности следует создавать только в событии draw. Если вы создадите поверхность в событии Create экземпляра, вы можете получить тот же индекс, что и у application_surface. Это может вызвать множество проблем
      и путаницу, поскольку вы думаете, что используете свою собственную поверхность, но на самом деле вы используете текущую цель рендеринга. Также всегда старайтесь ограничивать рисование на поверхности в событии draw, поскольку из-за оптимизированного способа, которым GameMaker
      Studio 2, рекомендуется держать все функции рисования в событии draw - это включает очистку поверхности при ее первом создании и т.д.. Рисование на поверхность вне события draw возможно и может быть
      даже необходимо для некоторых эффектов, но так делать не следует.
    В-четвертых, при рисовании на поверхности вручную поверхность всегда находится в позиции (0,0). Это означает, что вам может понадобиться преобразовать абсолютные координаты в относительные для поверхности. Например, если у вас есть
      поверхность размером с камеру и вы хотите нарисовать что-то, что в данный момент видно в камере, на этой поверхности, вы должны вычесть координаты x и y вида камеры из фактических координат x и y, чтобы получить относительную позицию относительно поверхности (0,0).
      позиция. Таким образом, код будет выглядеть примерно так:
  
  if view_current = 0 { surface_set_target(surf);
     with (obj_Effect) {
     var _vx = camera_get_view_x(view_camera[1]); var _vy = camera_get_view_y(view_camera[1]); draw_sprite(sprite_index, image_index, x - _vx, y - _vy); }
     surface_reset_target();
     }
     else
     {
     draw_surface(surf, 0, 0); }
  
  
    Наконец, стоит отметить, что при рисовании на поверхности будет учитываться цвет и альфа-компонент каждого пикселя, как самой поверхности, так и того, что на нее рисуется. Это может привести к довольно неинтуитивным
      результатам (например, при рисовании спрайта с альфа-составляющей 0,5 на поверхность с альфа-составляющей 0 получится итоговая альфа-составляющая 0,25). Причины этого объясняются на следующей странице, и мы рекомендуем вам прочитать ее перед началом работы с поверхностями: Руководство по использованию блендмодов
  
  ПРИМЕЧАНИЕ: Это не относится к поверхности приложения, только к поверхностям, созданным пользователем.
  Основное использование поверхности может быть следующим:
  
    Сначала вы создаете поверхность и присваиваете ее индекс переменной.
    В этом случае цель рисования будет задана на поверхности, а не на дисплее.
    Далее вы рисуете то, что хотите, а также выполняете любые другие манипуляции.
    После завершения работы вы сбрасываете цель рисования, чтобы все дальнейшее рисование снова происходило на экране.
    Наконец, вы нарисуете поверхность (или используете ее в шейдере, или что-то еще).
  
  Следует отметить, что если вам нужно перерисовать весь дисплей на поверхность (включая плитки, фон и т.д.), вы можете просто обратиться к самой поверхности приложения (подробнее см. ниже) или назначить поверхность порту представления
    используя переменную view_surface_id[0..7] в этом случае все, что видно в данном порту представления, будет отрисовано на соответствующей поверхности.
  Для работы с поверхностями существуют следующие функции (эти функции предназначены для создания и манипулирования поверхностями, но чтобы нарисовать их на экране, необходимо использовать специальные функции рисования, которые можно найти ниже):
   
  
    поверхность_существует
    поверхность_создать
    поверхность_создать_экст
    размер_поверхности
    поверхность_задать_цель
    surface_set_target_ext
    surface_get_target
    surface_get_target_ext
    поверхность_сброса_цели
    поверхностное_копирование
    поверхность_копирования_части
    глубина_поверхности_запрещена
    surface_get_height
    surface_get_width
    поверхность_get_текстура
    surface_get_depth_disable
    поверхность_getpixel
    surface_getpixel_ext
    поверхность_свободная
    поверхность_сохранения
    поверхность_сохранить_часть
  
   
  Для рисования поверхностей существуют следующие функции:
  ПРИМЕЧАНИЕ: При работе с поверхностями существует вероятность того, что они могут прекратить свое существование в любой момент, поскольку хранятся в памяти текстуры. Вы должны ВСЕГДА проверять существование поверхности с помощью функции surface_exists() перед тем, как
    обращаться к ней напрямую.
   
  
    нарисовать_поверхность
    нарисовать_поверхность_экст
    нарисовать_поверхность_части
    нарисовать_поверхность_части_экст
    нарисовать_поверхность_растянутой
    draw_surface_stretched_ext
    нарисовать_поверхность_плиткой
    draw_surface_tiled_ext
    рисовать_поверхность_общая
  
   
  Наконец, у вас есть две функции для хранения и извлечения поверхностей в буферах:
   
  
    buffer_get_surface
    buffer_set_surface
  
   
  Как упоминалось выше, в GameMaker Studio 2 большинство вещей не выводится на экран напрямую, вместо этого они выводятся на поверхность приложения. Это, по сути, поверхность - такая же, как и любая другая, которую вы можете создать самостоятельно с помощью функций
    surface functions - и как таковой, ею можно манипулировать, рисовать на ней, посылать шейдерам и т.д.. В принципе, все, что вы обычно делаете с созданной вами поверхностью, можно применить и к поверхности приложения.
  ПРИМЕЧАНИЕ: Единственное, что вы не можете сделать с поверхностью приложения, - это освободить ее. Она всегда существует, хотя значение индекса для доступа к ней может меняться.
  Когда вы запускаете свою игру, эта поверхность создается при первом вызове события draw в каждой новой комнате, в которую вы входите, что означает, что до этого момента ничего не рисуется.
    момента. Однако вы все равно можете получить положение поверхности приложения и изменить ее размер в событии Create или любом другом событии без каких-либо ошибок, а используемые значения будут относиться к поверхности в момент ее создания. Фактическая последовательность
    событий для создания и рисования поверхности приложения выглядит следующим образом:
  
    Событие перед отрисовкой --- > создается поверхность приложения (если она не существует) и устанавливается цель отрисовки.
    Для каждого видимого порта просмотра или, если ни один порт просмотра не активен, один раз.
      
        Событие начала рисования
        событие рисования
        Событие окончания рисования --- > здесь происходит сброс цели рендеринга поверхности приложения
      
    
    Post draw event --- > теперь поверхность приложения по умолчанию рисуется в буфер дисплея . 
	                 (хотя вы можете отключить это с помощью application_surface_draw_enable())
    Событие начала рисования графического интерфейса пользователя
    Событие рисования графического интерфейса
    Событие окончания рисования графического интерфейса
  
  Использование этой поверхности означает, что вы можете легко создавать невероятные переходы с помощью шейдеров, или взять экран и обернуть его вокруг 3D-формы, или просто масштабировать игру с низким разрешением до экрана любого разрешения... Возможности безграничны!
  Чтобы получить доступ к этой поверхности, необходимо использовать встроенную глобальную переменную application_surface, которая описана на следующей странице:
   
  
    поверхность_приложения
  
   
  У вас также есть несколько специализированных функций, предназначенных только для работы с поверхностью приложения:
   
  
    приложение_поверхность_включено
    приложение_поверхность_является_включенным
    application_get_position
    application_surface_draw_enable
  
   
   
   
  
    
      
        Назад: Рисунок
        Следующее: Освещение
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

