
  
  Аксессоры
   Язык GameMaker Language(GML) также позволяет получать доступ к определенным структурам данных и массивам с помощью логических выражений, называемых аксессорами. Этот
    построено так же, как и при обычной работе с массивом, только перед первым аргументом используется символ идентификатора, чтобы сообщить GameMaker Studio 2, что вы работаете со структурой данных (ранее созданной) или литералом массива.
    литерал.
   
  Списки DS [| ]
  
    Синтаксис для списков DS следующий:
    list_index[| index]
    Поэтому, когда вы используете ds_list_create() для создания списка, вы будете использовать индекс списка (который вы сохранили в переменной) для ссылки на него, при этом значение "index" будет позицией в списке, которую нужно установить или добавить. Например.
      следующий код создает список, а затем добавляет 10 записей, устанавливая для каждой записи случайное число от 0 до 9:
    ds = ds_list_create(); var index = 0; repeat(10)
       {
       ds[| index++] = irandom(9); }
    
    Обратите внимание, что если вы используете выражение для добавления ссылки на индекс, который уже имеет значение, предыдущее значение будет заменено, а не добавлен новый индекс в список. Для добавления последующих записей необходимо знать размер списка ds_list
      и добавить их в конец. Также стоит отметить, что вы можете задать индекс списка, который больше, чем размер списка, на который ссылаются, и в этом случае будет установлено это значение, одновременно расширяя список и инициализируя все позиции
      в списке до заданного индекса как 0.
    После того как вы создали структуру списка и заполнили ее данными, для получения значений из списка вам потребуется что-то вроде:
    значение = ds[| 5];
    Вышеприведенная команда получит значение из позиции 5 (шестой индекс, так как списки начинаются с 0) и сохранит его в переменной. Если вы зададите позицию, которая находится за пределами размера списка, то будет возвращено значение undefined, которое можно проверить с помощью функции
      с помощью функции is_undefined().
     
  
  Карты DS [?]
  
    Синтаксис для карт DS следующий:
    map_index[? key]
    После создания карты с помощью ds_map_create(), вы будете использовать индекс карты, который вы сохранили в переменной, чтобы ссылаться на нее, а значение "key" будет ключом карты, который нужно установить или получить. Например, следующий код создает карту и
      затем добавляет в нее несколько записей, используя этот синтаксис:
    ds = ds_map_create(); ds[? "Name"] = "Hamish"; ds[? "Company"] = "MacSeweeny Games"; ds[? "Game"] = "Catch The Haggis";
    Обратите внимание, что если карта уже содержит то же значение ключа, которое вы пытаетесь добавить, она не создаст дубликат ключа с новым значением, а заменит предыдущее значение.
    После того как вы создали структуру карты и заполнили ее данными, для получения значений по определенному ключу карты вы должны сделать следующее:
    значение = ds[? "Имя"];
    Приведенное выше действие получит значение из ключа "Name" и сохранит его в переменной, но имейте в виду, что если данный ключ не существует в карте DS, то возвращаемое значение будет неопределенным. Это можно проверить с помощью функции
      is_undefined().
     
  
  DS Grids [# ]
  
    Синтаксис для DS grid следующий:
    grid_index[# xpos, ypos]
    После создания сетки с помощью функции ds_grid_create(), вы будете использовать индекс сетки, который вы сохранили в переменной, для ссылки на нее, при этом "xpos" и "ypos" будут позицией в сетке, чтобы получить или установить значение
      значение. Например, следующий код создает сетку, очищает ее до 0, а затем добавляет в нее несколько записей:
    ds = ds_grid_create(); ds_grid_clear(ds, 0); var gw = ds_grid_width(ds) - 1; var gh = ds_grid_height(ds) - 1; repeat(10)
       {
       var xx = irandom(gw); var yy = irandom(gh); if (ds[# xx, yy] == 0) {
       ds[# xx, yy] = 1; }
       }
    
    После того как вы создали структуру сетки и заполнили ее данными, для получения значений из определенной позиции сетки вы должны сделать следующее:
    value = ds[# mouse_x div 16, mouse_y div 16];
    Вышеприведенная функция получит значение из заданной ds_grid на основе позиции мыши (разделенной на ширину "ячейки" в комнате, чтобы получить правильное местоположение). Если вы зададите позицию, которая находится вне границ сетки, то будет возвращено значение undefined, которое можно проверить с помощью функции is_undefined().
     
  
  Массивы [@ ]
  
    Массивы также имеют свои собственные аксессоры, которые работают аналогично перечисленным выше для структур данных. Однако аксессоры массивов обладают интересным свойством, позволяющим изменять массив из функции или метода скрипта без необходимости его копирования. Когда вы передаете массив в функцию, он передается по ссылке, то есть сам массив не передается в скрипт, а просто
      на него ссылаются для получения данных. Обычно, если вам нужно изменить массив, он копируется в скрипт, а затем вам нужно передать обратно (вернуть) скопированный массив, чтобы исходный массив был обновлен. Это может привести к дорогостоящим
      накладные расходы на обработку, поэтому вместо этого можно использовать аксессор, который изменит исходный массив напрямую , без необходимости его копирования. Вы можете увидеть, как это работает, в примерах ниже.
    Синтаксис для массивов следующий:
    array[@ xpos]
    После того как вы создали массив в экземпляре, вы можете передать его в сценарий по ссылке и использовать аксессор @ для его непосредственного изменения. Например, вы создадите массив и вызовете функцию следующим образом:
    array[99] = 0; array_populate(array);
    
    Сама функция будет выглядеть примерно так:
    function array_populate(_array) { var a = _array; var i = 0; repeat(25) { i = irandom(99); while (a[i] != 0) { i = irandom(99); }  
        a[@ i] = 100; }  }
    Все, что делает эта функция, это выбирает 25 случайных позиций в массиве и устанавливает значение выбранной позиции массива равным 100.
    ПРИМЕЧАНИЕ: Вы не можете использовать аксессор массива @ при работе с массивом argument[n] в скриптовых функциях.
     
     
  
  Структуры [$ ]
  
    Синтаксис для структур следующий
    struct[$ "name"]
    Этот аксессор по сути является оберткой для функций variable_struct_get() и variable_struct_set(),
      и вы будете использовать его так же, как и аксессор для DS map. Например, если вы создали структуру и хотите получить значение из переменной под названием "my_health", вы должны сделать следующее:
    
    var _hp = struct[$"my_health"];
    Как видите, вы передаете не саму переменную, а строку с ее именем. Обратите внимание, что если в структуре нет переменной с заданным именем, то аксессор вернет undefined как
      значение.
    Чтобы задать переменную в структуре, нужно сделать следующее
    struct[$ "my_score"] = 100;
    Как и в случае с получением значения, вы указываете имя переменной для установки в виде строки, и она будет установлена в заданное значение. Если используемое имя переменной не существует в структуре, то она будет создана и установлена в заданное значение.
    
  
   
  Важной особенностью аксессоров является то, что их можно объединять в цепочки. Это означает, что если у вас есть несколько вложенных структур данных и/или массивов, больше нет необходимости использовать множество функций, чтобы получить доступ к значению, которое находится в глубине вложенной структуры.
    находится глубоко во вложенной структуре. Например, у вас есть массив, и каждый элемент в массиве представляет собой список DS, например, так:
  array = array_create(3); for (var i = 0; i < 3; ++i;) {
     array[i] = ds_list_create(); switch(i)
     {
     case 0: with (obj_Wall) ds_list_add(array[i], id); break;
     case 1: with (obj_Door) ds_list_add(array[i], id); break;
     case 2: with (obj_Chest) ds_list_add(array[i], id); break;
     }
     }
  
  В приведенном выше коде мы создали массив из 3 элементов и назначили каждому из них список DS, а затем заполнили различные списки идентификаторами экземпляров различных объектов в игре. Теперь, чтобы получить доступ к идентификатору в одном из списков, мы можем сделать следующее
    следующее:
  var _list = array[0]; var _id = ds_list_find_value(_list, 0);
  Однако вы можете сделать то же самое, используя цепочку аксессоров, гораздо более чистым способом, который использует меньше кода:
  var _id = array[0][| 0];
  Таким образом можно объединить в цепочку несколько аксессоров, причем они могут быть разных типов, чтобы получить доступ к информации, хранящейся в каждой части вложенной структуры. Вот еще несколько примеров:
  // Доступ к сетке, которая была добавлена в список, являющийся частью карты: var _a = data[? "lists"][| 0][# 0, 0];
     // Доступ к массиву, вложенному в список, из скрипта и его изменение: data[| 0][@ 10] = 100;
     // Доступ к карте, вложенной в сетку, вложенную в список, вложенный в массив: data[0][| 10][# 3, 4][? "key"] = "hello world";
  Использование цепочек аксессоров для вещей не только означает, что вы сможете писать более компактный код, но и позволит вам использовать итерацию (например, с помощью для цикл) и другие техники для доступа к данным в
    более чистым и интуитивно понятным способом.
  Стоит отметить, что при использовании аксессоров таким образом всегда следует использовать аксессор @ для массивов, так как в противном случае вы будете добавлять дополнительные накладные расходы на любые выполняемые действия. Как упоминалось выше, по умолчанию массивы
    передаются в функции по ссылке и при изменении используют поведение "копирование при записи". Однако если массив является частью цепочки, то предыдущий элемент в цепочке будет обновлен скопированным массивом, а "оригинал"
    будет удален. Например, если сделать примерно следующее:
  // В событии объекта data[| 0][0] = 100;
     // В функции data[| 0][0] = 200;
  достигает тех же результатов, что и при выполнении этого действия:
  // В событии объекта data[| 0][0] = 100;
     // В функции data[| 0][@ 0] = 200;
  Однако второй пример лучше, поскольку он работает без лишних затрат на копирование всего массива.
   
   
   
  
    
      
        Назад: ОбзорGML
        Следующий: Функции и переменные сценария
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

