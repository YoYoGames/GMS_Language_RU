
  
  Статические переменные
  Интересной особенностью функций сценария и переменных метода является то, что они могут иметь статические переменные. Статическая переменная - это переменная, которая определяется в первый раз, когда
    при первом вызове функции и сохраняет свое значение в дальнейшем. Чтобы создать статическую переменную, необходимо определить ее с помощью ключевого слова static, как показано в этом простом примере:
  counter = function() {
     static num = 0; return num++; }
  
  В приведенном выше примере переменная num является статической переменной, поэтому при первом вызове функции она будет определена как 0, но при каждом последующем вызове функции инициализация переменной будет игнорироваться.
    игнорируется. Поэтому, если вы вызовете эту функцию следующим образом:
  for (var i = 0; i < 10; ++i;) {
     show_debug_message(counter()); }
  
  Выходные данные будут такими:
  0 1
     2
     3
     4
     5
     6
     7
     8
     9
  
  Если бы вы не использовали здесь ключевое слово static, то на выходе был бы просто 0 для каждой итерации цикла, так как переменная num будет определяться как 0 каждый раз, когда
    функция вызывается перед возвратом. Обратите внимание, что статическая переменная может быть изменена только внутри исходной функции, и возврат ее просто даст вам копию ее значения - по сути, общая статическая переменная может быть изменена только той
    функция, которая ее содержит.
  Статическая переменная всегда инициализируется в верхней части функции, поэтому независимо от того, где вы определяете статическую переменную в функции, она всегда будет доступна для чтения и изменения на протяжении всей функции (даже если она используется до того, как была определена).
    См. следующий пример:
  function add_health() {
     my_health++; show_debug_message(my_health); static my_health = 1; }
  
  Здесь статическая переменная " my_health" изменяется и выводится в вывод компилятора до инициализации. Хотя это выглядит неправильно, это совершенно нормально, потому что статические переменные инициализируются до выполнения любого
    кода функции. Обратите внимание, что если в функции несколько статических переменных, то при их инициализации сверху сохраняется порядок, в котором они были определены.
  Вы также можете использовать ключевое слово static внутри функции для создания статической функции, что - как и в случае с переменными - просто означает, что функция будет определена только один раз, то есть при первом вызове функции.
    вызывается, например:
  function(_x, _y) Vector2 constructor {
     x = _x; y = _y;
     static Add = function( _other ) { x += _other.x; y += _other.y; }  }
  
  В приведенном выше примере функция конструктора Vector2 может быть использована для создания структуры, а структура будет иметь несколько переменных, одной из которых является переменная метода Add. Поскольку
    эта переменная была определена как статическая, функция, которую она содержит, будет инициализирована только один раз при первом вызове функции Vector2, и все последующие структуры, созданные с помощью этого конструктора, будут ссылаться на функцию , которая была создана изначально, вместо того, чтобы создавать новую функцию.
    на функцию Add, которая была создана изначально, вместо того, чтобы создавать новую функцию для каждой структуры (более подробную информацию о структурах и ключевом слове constructor можно найти здесь).
  При использовании наследования с конструкторами любые статические переменные в дочернем конструкторе будут инициализированы только после выполнения родительского конструктора, поэтому статические переменные дочернего конструктора не будут переопределять статические переменные родительского конструктора.
    переменные. Смотрите следующий пример:
  function Parent() constructor {
     show_debug_message(value); static value = 10; }
    
     function Child() : Parent() constructor {
     show_debug_message(value); static value = 20; }
    
     var _child = new Child();
  Вызов конструктора Child() выводит это в журнал вывода:
  10 20
  
  Первое значение - из родительского конструктора, а второе - из дочернего конструктора. Это показывает, что значение статической переменной дочернего конструктора не было инициализировано до завершения работы родительского конструктора, и что в каждом конструкторе
    статическая переменная была инициализирована до вызова show_debug_message().
   
   
  
    
      
        Назад: ОбзорGML
        Следующее: Структуры
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

