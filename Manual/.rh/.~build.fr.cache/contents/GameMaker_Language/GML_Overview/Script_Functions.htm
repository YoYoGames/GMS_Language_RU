
  
  Функции и переменные сценария
  Активы сценария - это, по сути, набор одной или нескольких функций или переменных, определенных пользователем, которые вы сами записываете в виде фрагментов кода в редакторе сценариев. Функции, которые вы определяете в сценарии, могут
    разрешать выражения, возвращать значения или делать все остальное, что позволяет язык GameMaker, как и встроенные функциивремени выполнения.
  Функции сценария обычно используются, если у вас есть блок кода, который вы используете в нескольких местах или объектах, или когда вы хотите, чтобы блок кода использовался в нескольких объектах модульно. Использование скриптов для определения функций означает, что
    вы можете изменить функцию только один раз, когда это необходимо, и изменение будет "подхвачено" каждым объектом, в котором есть вызов функции.
  Скрипты также могут быть очень удобны с организационной точки зрения, так как они позволяют создавать группы функций, относящихся к определенной категории - например, у вас может быть несколько функций, связанных со столкновениями между экземплярами в вашей
    Например, у вас может быть несколько функций, связанных со столкновениями между экземплярами в вашей игре, тогда вы создадите скрипт "Collision_Functions" и будете хранить в нем все эти функции вместе.
  Создание функций
  При создании сценария с функциями в нем, функции должны быть созданы с использованием следующих форматов:
  function <name>( <parameter1>, <parameter2>, etc... )
{
        <statement1>;
        <statement1>;
        ...
    }
  или:
  <имя> = function( <параметр1>, <параметр2>, и т.д... )
    {
        <statement1>;
        <statement1>;
        ...
    }
  В общем случае, однако, для скриптовых функций следует использовать первую форму, так как она определяет функцию именно как скриптовую, то есть она будет глобальной по области применения,
    ей будет присвоен индекс скрипта, и не потребуется префикс global для ее идентификации, поскольку компилятор распознает ее как скрипт-функцию. При использовании второй формы вместо этого будет создана глобальная область видимости
   переменную метода, и как таковая она не будет распознана IDE как функция сценария и потребует использования префикса global при ссылке на нее в вашем коде.
  ПРИМЕЧАНИЕ: Вы можете проверить это, используя обе формы в сценарии, а затем вызвав функцию typeof() для каждой из них. Одна из них будет классифицирована как "число" - поскольку
    она возвращает идентификатор индекса сценария, а другая будет классифицирована как "метод".
  Аргументы
  Вы можете определить собственные параметры/аргументы для функции, которые будут доступны функции как локальные переменные и могут быть использованы любым образом:
  function move(spd, dir) {
     скорость = spd; направление = dir; }
  
  Эта функция принимает два аргумента и применяет их значения к переменным скорости и направления движения экземпляра. Теперь ее можно вызывать как любую функцию времени выполнения и передавать в нее аргументы:
  var _mouse_dir = point_direction(x, y, mouse_x, mouse_y);
    
   move(4, _mouse_dir);
  Обратите внимание, что если аргумент не передан функции, его значение будет неопределенным. Вы можете использовать это для определения необязательных аргументов и проверять, передан аргумент или нет, проверяя, равен ли он undefined. Однако,
    вы также можете определить значение по умолчанию для аргумента, которое будет использоваться вместо undefined, если он не передан.
  Вы можете присвоить такое значение по умолчанию параметру с помощью знака равенства(=), сделав его необязательной переменной:
  function move(spd, dir = 90) {
     скорость = spd; направление = dir; }
  
  Если аргумент dir не передан при вызове вышеуказанной функции, то его значение по умолчанию будет равно 90, что приведет к перемещению экземпляра в направлении вверх.
  Значением по умолчанию необязательной переменной может быть выражение, поэтому, например, при определении необязательной переменной можно использовать переменные и вызывать функции. Обратите внимание, что такое выражение будет выполнено только в том случае, если его необязательный аргумент не указан
    в вызове функции. См. следующий пример функции протоколирования:
  function log(text = "Log", object = object_index, time = date_datetime_string(date_current_datetime())) {
     var _string = "[" + string(time) + "] "; _string += object_get_name(object) + ": "; _string += text;      show_debug_message(_string); }
  
  Эта функция принимает три аргумента, где первый аргумент по умолчанию является строковой константой, второй аргумент по умолчанию является переменной экземпляра (в области видимости вызывающего экземпляра), а третий аргумент по умолчанию является выражением, вызывающим функцию
    для получения текущей даты и времени. Теперь эта функция может быть вызвана с тремя аргументами, как показано в следующем примере:
  log(); // Prints: [09-Jun-21 12:34:37 PM] Object1: Log
     log("Player Shot", obj_player, 10); // Prints: [10] obj_player: Выстрел игрока
  JSDoc
  Мы также рекомендуем добавлять комментарии для определения свойств функции (подробнее см. раздел " Комментарии JSDoc" ), например, простой сценарий может выглядеть следующим образом
    выглядел следующим образом:
  /// @function log(message); /// @param {string} message Сообщение для показа /// @description Показывайте сообщение при каждом вызове функции.
     function log(message) {
     show_debug_message(message);
     }
  
  Дополнительные функции для скрипта могут быть добавлены в том же формате, как показано выше, одна за другой внутри актива скрипта.
  
  Возвращаемое значение
  Функции в сценариях также могут возвращать значение, как и функции времени выполнения, и поэтому их можно использовать в выражениях. Для этого вы можете использовать return оператор:
  вернуть <выражение
  Следует заметить, что в качестве параметра возврата используется выполнение функции заканчивается на операторе returnозначает, что любой код, пришедший после вызова return , не будет выполнен. Вот короткий пример функции из
    функция под названием "sqr_calc", которая вычисляет квадрат любого переданного ей значения, и в случае, если данное значение не является действительным числом, она использует return для досрочного завершения функции, так что фактическое вычисление никогда не выполняется.
    вычисление никогда не выполняется:
  /// @function sqr_calc(val); /// @param {real} val Значение для вычисления квадрата /// @description Вычисление квадрата заданного значения
     function sqr_calc(val) {
     if !is_real(val) {
     return 0; }
    
     return (val * val); }
  
  Обратите внимание, что если вы создадите функцию скрипта без возвращаемого значения, а затем в своем коде проверите его наличие, то по умолчанию вы получите значение undefined.
  Чтобы вызвать функцию скрипта из кода, просто используйте ее так же, как и при вызове любой функции времени выполнения - то есть напишите имя функции со значениями параметров в круглых скобках. Таким образом, приведенный выше сценарий будет вызываться следующим образом:
  if keyboard_check_pressed(vk_enter) {
     val = scr_sqr(amount); }
  
  ПРИМЕЧАНИЕ: При использовании собственных функций из скриптов в редакторе кода можно нажать кнопку  или нажать среднюю кнопку мыши  на
    на имени функции, чтобы открыть содержащий ее сценарий для редактирования.
  Имена сценариев в сравнении с именами функций
  Важно понимать, что имена скриптов не зависят от функций, которые они содержат, поэтому вы можете называть свои скрипты более "здравым" образом, т.е.: все ваши функции AI могут находиться в скрипте "Enemy_AI".
    (следуя стандартным соглашениям об именовании активов, состоящим только из буквенно-цифровых символов и символа "_"). Однако, вы все еще можете вызывать скрипты в вашей игре - и вы можете называть скрипты так же, как и функции, которые вы определяете в них - что
    может привести к возникновению проблем из-за способа хранения ссылок на активы в GameMaker Studio 2. Для примера рассмотрим этот код, вызываемый из экземпляра:
  function indirectCall(func, arg) {
     func(arg);
     }
    
     indirectCall(myscript, arg);
  Приведенный выше код пытается вызвать сценарий под названием "myscript" внутри метода, что в данном случае приведет к неудаче. Это происходит потому, что встроенная функция фактически использует индекс для актива скрипта, а не фактически
    например: если индекс скрипта разрешается в "4", то, по сути, функция вызывает 4(arg); , что не имеет смысла. Вместо этого код должен быть структурирован одним из следующих двух способов:
  function indirectCall(func, arg) {
     func(arg);
     }
    
     indirectCall(method(undefined, myscript), arg);
     // ИЛИ
     function indirectCall(func, arg) {
     script_execute(func, arg); }
    
     indirectCall(myscript, arg);
  Это важно отметить, особенно при работе со старыми проектами, где скрипты содержат одну единственную функцию, и функция называется так же, как и скрипт. Однако на самом деле так делать никогда не следует, и ваши скрипты должны иметь имена
    независимо от функций, которые они содержат.
  Объем сценария
  Это подводит нас к последней и самой важной вещи, которую необходимо знать о скриптах и функциях, которые они содержат: скрипты анализируются на глобальном уровне и компилируются в самом начале игры. Это означает, что технически все функции в скрипте являются "несвязанными" переменными метода , а любые переменные, объявленные вне функции в скрипте, будут считаться глобальными переменными.
    Например, рассмотрим этот скрипт:
  function Foo() {
     // Сделайте что-нибудь }
     blah = 10; function Bar() {
     // Сделайте что-нибудь еще }
  
  В приведенном выше случае мы определили не только функции Foo и Bar, но и переменную blah, и все они считаются созданными в глобальной области видимости. Для распознавания функций не требуется ключевое слово global, так как компилятор понимает, что эти функции являются частью сценария, но если бы вы захотели получить доступ к blah, то вам пришлось бы это сделать:
  val = global.blah;
  Тем не менее, мы рекомендуем всегда явно указывать глобальные переменные при их создании в скриптах, чтобы избежать проблем в дальнейшем. Сценарии также являются идеальным местом для определения любых макросов или Enums(констант),
    поскольку добавление их в скрипт вне функции означает, что они будут созданы для использования до того, как код игры начнет выполняться. Ниже приведен пример скрипта, который создает различные значения глобальной области видимости для игры:
  /// Инициализация всех глобальных значений и констант global.player_score = 0; global.player_hp = 100; global.pause = false; global.music = true; global.sound = true;
     enum rainbowcolors {
     красный, оранжевый, желтый, зеленый, синий, индиго, фиолетовый }
    
     #macro weapon_num 3 #macro weapon_gun 0 #macro weapon_bomb 1 #macro weapon_knife 2
  Обратите внимание, что все эти константы устанавливаются вне вызова любой функции, что означает, что они будут инициализированы до всего остального и в глобальной области видимости. Это означает, что если вы хотите использовать скрипт для инициализации переменных в области видимости экземпляра 
    то вы должны обернуть их в функцию, например:
  /// @function init_enemy(); /// @description Initialise enemy instance vars
     function init_enemy() {
     hp = 100; dmg = 5; mana = 50; }
  
  Так, скрипты можно использовать для создания макросов, перечислений и глобальных переменных до начала игры, чтобы они были готовы к использованию в любое время, а также для создания "несвязанных" методов (функций, определяемых пользователем), которые можно использовать в вашей игре
    как функции времени выполнения GML.
  И последнее, что следует отметить о функциях скриптов: если вы разрабатываете для Web (т.е. ориентируетесь на HTML5), то существует дополнительный протокол функций, который вы можете использовать при добавлении функций в скрипты, а именно
    префикс имени функции с gmcallback_, например:
  gmcallback_create_button
  Использование приведенного выше имени функции означает, что функция gmcallback_create_button() не будет обфусцирована и поэтому может быть использована в расширениях JavaScript и других областях вашей игры, например, при использовании clickable_* функции.
  Статические переменные
  Функции также могут использовать статические переменные, которые сохраняют свои значения при каждом вызове функции. Для получения дополнительной информации прочтите эту страницу.
   
   
  
    
      
        Назад: ОбзорGML
        Следующий: Переменные метода
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

