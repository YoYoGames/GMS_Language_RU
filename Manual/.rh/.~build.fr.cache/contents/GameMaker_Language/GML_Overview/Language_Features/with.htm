
  
  с
  Как указано в разделе Обращение к переменным в других экземплярах, можно читать и изменять значение переменных в экземплярах и структурах, отличных от того, который в данный момент выполняет тот или иной код.
    того, который в данный момент выполняет любой данный код. Однако в ряде случаев вы захотите сделать гораздо больше, чем просто изменить одну переменную в этих других экземплярах, и, возможно, захотите выполнить более сложные действия в коде, требующие нескольких функций
    и строк кода. Например, представьте, что вы хотите переместить все экземпляры объекта ball в вашей игре на 8 пикселей вниз. Вы можете подумать, что это достигается простым выполнением следующего фрагмента кода:
  obj_ball.y = obj_ball.y + 8;
  Но это неверно, поскольку правая часть присваивания получает значение координаты y первого шарика и прибавляет к нему 8. Затем это новое значение устанавливается в качестве координаты y всех шариков, в результате чего все шарики получают одинаковую координату y,
    и даже если вы используете следующее:
  obj_ball.y += 8;
  будет иметь точно такой же эффект, потому что это просто сокращение первого утверждения. Как же добиться чего-то подобного? Именно поэтому в GML существует оператор with. Утверждение with 
    имеет следующий синтаксис:
  with (<выражение>) { <выражение>; <выражение>;... }
  Для выражения можно указать один или несколько экземпляров (или структуру) для выполнения кода, используя идентификатор экземпляра, идентификатор объекта (который указывает, что все экземпляры в комнате
    этого объекта должны выполнить блок кода), идентификатор структуры или одно из специальных ключевых слов(all или other). Это изменит область видимости кода внутри фигурных скобок
    {} с экземпляра, структуры или функции, в которой фактически содержится код, на экземпляр (или экземпляры, или структуру), указанный в выражении.
  После того как выражение установит область видимости with, оператор будет выполняться для каждого из указанных экземпляров, как если бы этот экземпляр был текущим (
    self ) экземпляром. Итак, возвращаясь к нашей исходной задаче, чтобы переместить все экземпляры объекта ball на 8 пикселей вниз, нужно ввести:
  with (obj_ball) {
     y += 8; }
  
  По сути, это цикл, и на каждой итерации цикла код будет выполняться на одном экземпляре объекта obj_ball.
  Если вы хотите выполнить несколько операторов, просто заключите их в фигурные скобки, как и любой другой блок кода. Например, чтобы переместить все шарики в нашем примере в случайное положение и придать им случайную скорость и направление,
    вы можете использовать:
  with (obj_ball) {
     x = random(room_width); y = random(room_height); speed = 1 + random(2); direction = random(360); }
  
  Как упоминалось выше, в операторе(ах) указанный экземпляр или структура стал целевым (self) экземпляром, который выполняет блок кода, что означает, что исходный экземпляр (который содержит with и
    весь блок кода) стал другое экземпляром. Так, например, чтобы переместить все шарики в позицию текущего экземпляра, который фактически содержит код, вы можете напечатать следующее:
  with (obj_ball) {
     x = other.x; y = other.y; }
  
  Высказывание with - это чрезвычайно мощный инструмент, который может быть полезен во многих и многих обстоятельствах, поэтому важно, чтобы вы полностью понимали, как его можно использовать. В помощь вам ниже приведено несколько примеров его использования:
  with (instance_create_layer(x, y, "Instances", obj_Ball)) {
     скорость = other.speed; направление = other.direction; }
  
  Приведенный выше код создаст экземпляр obj_Ball и присвоит ему скорость и направление того экземпляра, который выполняет весь блок кода.
  with (instance_nearest(x, y, obj_Ball)) {
     instance_destroy();
     }
  
  Приведенный выше код уничтожит экземпляр obj_Ball, ближайший к экземпляру, выполняющему код.
  with(clone_struct) { xx = other.x; yy = other.y; spd = other.speed; dir = other.direction; }
  Приведенный выше код использует with для нацеливания на struct и установки переменных-членов struct в значения, хранящиеся в переменных экземпляра из экземпляра, вызывающего код.
  var _inst = noone; with (obj_ball) {
     if (str > other.str) {
     _inst = id; }
     }
     if (_inst != noone) {
     target = _inst; }
  
  Приведенный выше код немного сложнее предыдущих из-за того, что в нем используется локальная переменная. Эта переменная является локальной либо для события, либо дляфункции сценария , а
    не экземпляру или структуре и поэтому может использоваться и быть доступной для всех экземпляров, на которые есть ссылки в блоке кода. Итак, в приведенном выше коде мы установили локальную переменную на специальное ключевое слово noone, а затем использовали конструкцию with 
    чтобы каждый экземпляр obj_Ball проверил свою переменную str на соответствие переменной экземпляра, на который ссылается данный блок кода. Если значение переменной больше, то они сохраняют свой уникальный ID в локальной переменной inst, а это означает, что
    что в конце кода в локальной переменной _inst будет сохранен только тот экземпляр, значение которого больше, чем у вызывающего экземпляра (или ключевое слово noone, если ни один экземпляр не больше).
  Стоит отметить, что вы можете использовать специальные операторы break и continue в пределах команды
    с также. При использовании break происходит немедленный выход из блока кода with и переход к любому коду, который находится в событии или функции после того, как код должен был завершиться.
    with должен был завершиться, например:
  var count = 0; with (obj_Enemy) {
     if (++count > 10) {
     break;
     }
     hp = 100; }
  
  Приведенный выше код перебирает все экземпляры объекта obj_Enemy в комнате и устанавливает переменную hp в значение 100 для первых 10 найденных экземпляров. Если найдено более 10 экземпляров, то код
    вызовет break и завершится.
  Примером использования continue в цикле with может быть:
  with (obj_Enemy_Parent) { if (invulnerable == true) { continue; }  hp -= 25; }
  Этот код перебирает все экземпляры с родительским obj_Enemy_Parent, затем проверяет каждый экземпляр на предмет того, является ли переменная экземпляра invulnerable переменной true или нет. Если
    это так, то ключевое слово continue завершает текущую итерацию цикла и переходит к следующему доступному экземпляру, иначе оно удаляет 25 из переменной hp. Так повторяется до тех пор, пока не будут проверены все экземпляры
    с этим родителем были проверены.
   
   
   
  
    
      
        Назад: Особенности языка
        Далее: возврат
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

