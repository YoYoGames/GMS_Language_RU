
  
  Массивы
  Массивы могут быть чрезвычайно полезны и являются неотъемлемой частью создания игр. Вот лишь несколько вещей, которые были бы невозможны (или, по крайней мере, намного сложнее) без массивов:
  
    Меню. Массив или два могут значительно облегчить создание хорошей системы меню.
    Ролевые игры. Массивы очень важны для создания ролевых игр, потому что вместо нагромождения переменных у вас есть всего несколько строк, к которым вы можете вернуться в любой момент.
    Карточные игры. Хорошо подходит для отслеживания карт и рук.
    Высокие баллы и другая статистика. Намного проще отслеживать один массив, чем несколько переменных.
  
  Это только вершина айсберга, поскольку массивы являются одним из самых фундаментальных и полезных инструментов программирования, и вы будете удивлены тем, какое применение они могут найти! Кроме того, они занимают очень мало памяти и, как правило, быстро разбираются,
    что делает их идеальными для поддержания максимальной производительности.
  Основной массив классифицируется как имеющий 1 размерность, но вы можете иметь массивы с более чем одной размерностью. В следующих разделах рассказывается об обоих типах массивов: 
   
  1 Размерные массивы
  
    Прежде чем продолжить, давайте уточним, что такое массив и как он устроен. Массив - это просто тип данных, который присваивается переменной, и он может содержать не одно, а несколько значений.
      значения. На рисунке ниже показана схема базового массива: 
    
    Это называется массивом 1D (одной размерности), и, как вы видите, массив хранится в переменной "a" и содержит несколько значений. Чтобы получить доступ к массиву, нужно сделать примерно следующее:
    var _val = a[0]; show_debug_message(_val);
    
    Приведенный выше код получает значение из позиции 0 массива "a", затем выводит его на консоль, которая, исходя из содержимого массива, показанного на рисунке выше, вывела бы 125. Если бы вы сделали следующее:
    var _val = a[3]; show_debug_message(_val);
    
    На выходе будет показано "Привет!".
    Как вы видите, вы задаете массиву имя переменной, а затем значение в квадратных скобках [], где значение - это позиция в массиве, из которой нужно получить данные. Таким образом, по сути, массив - это контейнер с определенным количеством пробелов для хранения значений.
      хранения значений, и каждая позиция в контейнере имеет определенный номер для идентификации, который мы и помещаем в []. Стоит отметить, что содержимое массива всегда начинается с 0 и никогда не может быть отрицательным!
    Мы показали, как проверить массив на наличие данных, но как создать массив для начала? Сначала его нужно инициализировать, прежде чем мы сможем его использовать, иначе GameMaker Studio 2 выдаст нам ошибку. Инициализация массива означает, что мы придаем каждой позиции массива начальное значение.
      позиции массива начальное значение, чтобы подготовить его к использованию в других местах кода проекта. Это важно помнить, так как это означает, что перед использованием массивов необходимо провести определенное планирование, но инициализировать массив достаточно просто.
      один из них с помощью цикла повтора, например, так...
    var i = 9; repeat(10)
       {
       array[i] = 0; i -= 1; }
    
    Этот простой код инициализирует десятипозиционный массив (от 0 до 9) для хранения 0, т.е. каждая позиция массива содержит значение 0. Вы заметите, что массив был инициализирован в обратном порядке, причем последнее значение было определено первым. Это
      не является строго необходимым, но это оптимальный способ, так как он резервирует место в памяти, которое точно соответствует размеру массива, в то время как если вы инициализируете массив от 0 вверх, память должна быть повторно выделена для каждого дополнительного
      (поэтому для массива из десяти элементов инициализация в цикле изменит распределение памяти десять раз). Разница в скорости незначительна для небольших массивов, но большие массивы должны быть максимально оптимизированы таким образом.
    ПРИМЕЧАНИЕ: Экспорт HTML5 является исключением из вышеуказанного правила, и при нацеливании на него следует инициализировать массивы в последовательном порядке от 0 вверх.
    Вы также можете использовать функцию GML array_create() для инициализации массива до фиксированного размера, и вы даже можете создавать "пустые" массивы без значений, например:
    my_array= [];
    Это сообщает программе GameMaker, что переменная "my_array" является массивом, и вы можете добавлять в него значения в любое время в будущем. Однако если вы попытаетесь получить доступ к значению в пустом массиве, то получите ошибку. На самом деле, вы всегда должны
      обращаться только к действительным позициям массива, так как попытка получить доступ к значению вне массива также приведет к ошибке. Например, это приведет к аварийному завершению проекта при запуске:
    my_array = array_create(5, 0); var _val = my_array[6];
    Массив был инициализирован только с 5 позициями, но мы пытались получить позицию 7 - массивы нумеруются от 0, поэтому array[6] - это позиция 7 - поэтому игра выдает ошибку и терпит крах.
    Мы показали, как инициализировать массив одним и тем же значением для каждой позиции, но что если мы хотим инициализировать массив разными значениями для каждой позиции? Для этого нам придется вручную набирать каждую позицию, но
      есть хороший трюк, который поможет нам следить за этим:
    var _count = 3; array[_count] = "you?" count -= 1; array[_count] = "are " count -= 1; array[_count] = "How " count -= 1; array[_count] = "Hello!" count -= 1;
    Как вы можете видеть, мы не использовали никаких чисел в самом массиве, а использовали локальную переменную для обратного отсчета значений. Это очень полезно, особенно для больших массивов, так как это означает, что вам не нужно
      не нужно отслеживать, сколько всего позиций и на каком номере вы находитесь, поскольку код позаботится об этом за вас. Вам просто нужно знать, сколько всего позиций вмещает массив.
    Наконец, вы можете присвоить значения массиву с помощью вызова одной переменной, как показано ниже:
    var _a = [0, 1, 2, 3, 4]; var _b = [];
    Приведенные выше действия создадут два массива в качестве локальных переменных, первый из которых уже заполнен 5 элементами, а второй - пустой массив, готовый к добавлению значений.
    Как использовать массив для практических целей? Точно так же, как мы используем обычную переменную, как показано в следующих примерах:
    // Складываем два значения массива вместе total = array[0] + array[5];
       // Проверяем значение массива if (array[9]) == 10 {
       // сделайте что-нибудь }
      
       // рисуем значение массива draw_text(32, 32, array[3]);
    Поскольку массивы нумеруются последовательно, это означает, что вы можете просмотреть их в цикле, чтобы выполнить дополнительные действия, точно так же, как мы это сделали для инициализации:
    var total = 0; for (var i = 0; i < 10; ++i;) {
       total += array[i]; draw_text(32, 32 + (i * 32), array[i]); }
       draw_text(32, 32 + (i * 32), total);
    Приведенный выше код суммирует все значения в нашем массиве, отрисовывает каждое из них и в конце выводит общее значение.
    Последнее, что следует упомянуть о массивах, это то, что вы также можете удалить массив, просто "переназначив" переменную, определяющую его, на одно значение. Это освободит память, связанную со всеми позициями и значениями для этого массива.
      Например:
    //Создаем массив for (var i = 9; i > -1; --i;) {
       a[i] = i; }
       //Удаление массива a = -1;
    Если массив имеет несколько измерений (см. ниже), все они также будут очищены, и обратите внимание, что при создании массивов в экземплярах их не нужно очищать при удалении экземпляра из игры, так как они будут удалены автоматически
     сборщиком мусора при уничтожении или завершении комнаты. Однако если какие-либо позиции массива содержат ссылки на динамические активы - например, системы частиц, буферы или структуры данных.
      - то их нужно будет уничтожить до удаления массива, уничтожения экземпляра или завершения комнаты.
     
  
  Многомерные массивы
  
    Мы знаем, что такое массив одного измерения, но в GameMaker Studio 2 вы можете иметь массивы с несколькими измерениями, которые по сути структурированы как массив внутри массива внутри массива... Например, ниже приведен двумерный (двухмерный) массив
    array[0][0] = 5;
    Это, по сути, сообщает GameMaker, что массив на самом деле состоит из различных одномерных массивов. Вот расширенный пример:
    array[1][2] = 1; array[1][1] = "hello"; array[1][0] = 55.5; array[0][2] = sprite_index; array[0][1] = "world"; array[0][0] = -67.89;
    Многомерный массив должен быть инициализирован перед использованием, как и одиночный одномерный массив, и может хранить вещественные числа, строки и любые другие типы данных, как и любая переменная.
      в которой необходимо хранить большие объемы данных в легкодоступном виде (помните, что вы можете легко выполнить цикл по массиву). Вот последний пример того, как это может быть использовано в реальной игре... Допустим, вы хотите породить четырех разных врагов в четырех разных
      в зависимости от случайной величины. Для этого мы можем использовать массив с двумя измерениями и не писать много кода.
    Сначала нам следует инициализировать массив, который мы будем использовать в событии create нашего объекта "controller" (обратите внимание на использование комментариев, чтобы напомнить вам, что делает каждый элемент массива):
    enemy[3][2] = 448; //y position enemy[3][1] = 32; //x position enemy[3][0] = obj_Slime; //Object enemy[2][2] = 448; enemy[2][1] = 608; enemy[2][0] = obj_Skeleton;  enemy[1][2] = 32; enemy[1][1] = 608; enemy[1][0] = obj_Knight; enemy[0][2] = 32; enemy[0][1] = 32; enemy[0][0] = obj_Ogre;
    Теперь у нас есть объекты для порождения экземпляров и соответствующие им координаты порождения x и y в комнате, сохраненные в нашем массиве. Теперь это можно использовать следующим образом в другом событии объекта контроллера (например, сигнал тревоги или нажатие клавиши
      событие):
    //получите случайное число от 0 до 3, включительно var i = irandom(3); //Используйте массив для создания объекта instance_create_layer(enemy[i][1], enemy[i][2], "Enemy_Layer", enemy[i][0]);
    Этот короткий код теперь породит случайного врага в игровой комнате, и он использует гораздо меньше кода, чем структура " if /then / else" или даже " switch", а поскольку массив инициализируетсяв событии create.
      гораздо легче редактировать и изменять любые из этих значений, поскольку они не закодированы в остальном коде проекта.
    Следует также отметить, что длина каждого измерения в массиве может быть разной, поэтому вы можете иметь начальное измерение массива длиной 3, но вторая запись измерения может быть разной длины для каждого из начальных значений массива.
      например:
    array[2][2] = "3"; array[2][1] = "2"; array[2][0] = "1"; array[1][3] = "четыре"; array[1][2] = "три"; array[1][1] = "два"; array[1][0] = "один"; array[0][1] = 2; array[0][0] = 1;
    Наконец, многомерные массивы не ограничиваются только двумя измерениями, и вы можете иметь 3, 4 или более измерений массива, как это требуется в вашем коде, просто добавив [n] дополнительные аргументы, например:
    array[0][0][0][0] = 1; // Трехмерный массив array[0][0][0][0] = 1; // Четырехмерный массив // и т.д....
  
   
  Как и обычные переменные, вы можете передавать массивы в функции сценария и переменные метода, чтобы они использовались и затем возвращались в экземпляр, вызвавший функцию. Для этого
    нужно просто указать переменную массива (не нужны ни отдельные позиции, ни скобки [] ), и весь массив будет передан по ссылке в функцию. Однако, если вы измените любое
    значения массива, массив будет скопирован во временный массив, предназначенный только для этой функции. Обратите внимание на использование слова временный! На самом деле вы не передаете в функцию сам массив (как это было бы с переменной
    переменную), но вместо этого вы просите функцию создать копию этого массива, которую вы будете изменять. Это означает, что вы всегда должны возвращать массив из функции, если хотите изменить какие-либо значения массива (такое поведение
    называется "копированиепри записи").
  ПРИМЕЧАНИЕ: В связи с тем, как это работает внутри функции, передача массивов в функции может повлиять на производительность, особенно если массив очень большой. Поэтому используйте эту функцию с осторожностью!
  В качестве примера рассмотрим следующий код. Сначала мы создаем массив, который хотим использовать, а затем передаем этот массив в функцию:
  for (var i = 9; i > -1; --i;) {
     a[i] = i; }
     my_array_func(a);
  
  Сама функция представляет собой нечто простое, например:
  my_array_func = function(array) {
     for (var i = 9; i > -1; --i;) {
     array[i] = i * 100; }
     }
  
  Теперь вы ожидаете, что конечный массив будет содержать значения 900, 800, 700 и т.д.. Но этого не произойдет, поскольку мы не вернули массив из функции, поэтому все, что мы изменили, это временную копию, которая была создана, когда мы передали массив в качестве аргумента в функцию.
    в качестве аргумента в функцию, и когда функция завершит работу, эта копия тоже исчезнет. Чтобы исправить это, мы должны были оформить код следующим образом:
  for (var i = 9; i > -1; --i;) {
     a[i] = i; }
     a = my_array_func(a);
  Теперь функция должна выглядеть следующим образом:
  my_array_func = function(array) {
     for (var i = 9; i > -1; --i;) {
     array[i] = i * 100; }
     return array; }
  
  ПРИМЕЧАНИЕ: Вышеуказанное не обязательно, если вы не изменяете значения массива, а просто ссылаетесь на них. При ссылке на массив он не копируется и разбирается быстрее.
  Также стоит отметить, что вы можете использовать аксессор @ для обращения к массиву из функции и изменения его значений напрямую, что экономит затраты процессора на его копирование в функцию. Вы можете получить дополнительную информацию об аксессорах
    и как они работают, а также пример для массивов можно найти на следующей странице:
  
    Аксессоры
  
   
   
   
  
    
      
        Назад: ОбзорGML
        Следующее: Типы данных
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

