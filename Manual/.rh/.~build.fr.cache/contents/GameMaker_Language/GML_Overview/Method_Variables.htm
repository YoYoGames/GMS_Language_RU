
  
  Переменные метода
  Переменная метода - это, по сути, переменная, которой назначена функция, "привязывающая" функцию к экземпляру и позволяющая использовать переменную для ссылки на функцию - точно так же, как вы используете имяфункции времени выполнения для ссылки на встроенную функцию GML . Используемая переменная может быть локальной, экземпляром или глобальной (более подробную информацию об области видимости переменных см. здесь ).
  Синтаксис для создания переменной метода следующий:
  <переменная> = function(<параметр1>, <параметр2>, и т.д... ) {
     <statement1>; <statement1>;... }
  
  или
  function <variablename>(<parameter1>, <parameter2>, etc... ) {
     <statement1>; <statement1>;... }
  
  В общем случае, однако, вы будете использовать первую форму для методов, а вторую - для определения скриптовых функций, поскольку вторая форма будет также присваивать индекс скрипта имени функции, в то время как первая
    будет "истинным" методом (и потребует использования глобального префикса, если используется для определения скриптовой функции).
  ПРИМЕЧАНИЕ: Вы можете проверить это, используя обе формы в проекте, а затем вызвав функцию выполнения typeof() для каждой из них. Одна из них будет классифицирована как "число" - поскольку
    она возвращает идентификатор индекса скрипта, а другая будет классифицирована как "метод".
  Поэтому имейте в виду, что в общем случае, говоря о методах и переменных методов, мы всегда будем ссылаться на функции, которые не были определены с помощью индекса сценария. 
  Ниже приведены три простых примера создания переменной метода с использованием различных диапазонов:
  // Local var _debug = function(message) {
     show_debug_message(message); }
    
     // Instance do_maths = function(val1, val2, val3) {
     return (val1 * val2) - val3; }
    
     // Глобальный global.pd = function(_x1, _y1, _x2, _y2); {
     return point_distance(_x1, _y1, _x2, _y2); }
  
  Обратите внимание, что в приведенном выше коде различные параметры, заданные в качестве входных данных для функции, имеют имена, и именно эти имена должны использоваться в функции для обозначения различных входных данных. Также обратите внимание, что вы можете использовать оператор return для возврата значения из функции для использования в других частях кода, и что функция, для которой не определено возвращаемое значение, по умолчанию возвращает undefined.
  ПРИМЕЧАНИЕ: Хотя переменная будет находиться в выбранной области видимости, фактическая функция будет привязана к той области видимости, в которой она была изначально определена. Например, функции сценария имеют глобальную область видимости и "не привязаны".
    (т.е. они не связаны ни с какими экземплярами), но если у вас есть функция скрипта, которая создает другую функцию в качестве переменной метода, а затем вы вызываете эту функцию скрипта из экземпляра, функция, используемая в скрипте, будет привязана к переменной экземпляра как метод.
    В общем случае об этом не нужно задумываться, но для более сложных операций с переменными метода это стоит принять во внимание. Это также применимо при использовании других конструкций, таких как with    - когда вы создаете переменную метода внутри функции with, функция будет привязана к экземпляру, который в данный момент находится в области видимости.
  После создания переменную метода можно использовать так же, как, например, функцию времени выполнения или функцию сценария:
  create_vec = function(_x1, _y1, _x2, _y2); {
     var _array; _array[0] = point_distance(_x1, _y1, _x2, _y2); _array[1] = point_direction(_x1, _y1, _x2, _y2); return _array; }
    
     vec = create_vec(x, y, mouse_x, mouse_y);
  Переменные, созданные внутри функции, подчиняются тем же правилам, что и обычные, и имеют область видимости в соответствии с используемым ключевым словом или областью видимости вызова функции. В приведенном выше примере мы используем var, поэтому переменная массива находится в
   локальной области видимости функции. Если бы мы не использовали ключевое слово, то переменная была бы создана в области видимости экземпляра, вызвавшего функцию.
  Методы, как и функции сценария, могут принимать необязательные аргументы, которые имеют значения по умолчанию, когда они не переданы:
  create_attachment = function(_attachment, _x = x, _y = y) {
     return instance_create_layer(_x, _y, layer, _attachment); }
  
  Приведенная выше функция принимает три аргумента, причем последние два являются необязательными. Если они не переданы при вызове функции, то по умолчанию будут использоваться координаты x и y экземпляра.
  Обратите внимание, что если аргумент не передан, и у него нет значения по умолчанию, то он будет равен undefined.
  Методы также могут использовать статические переменные, которые сохраняют свои значения при каждом вызове функции. Для получения дополнительной информации прочтите эту страницу.
  Ниже мы перечислим несколько вспомогательных функций, связанных с переменными метода:
  
    is_method
    метод
    метод_get_self
    метод_get_index
  
   
   
   
  
    
      
        Назад: ОбзорGML
        Следующее: Структуры
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

