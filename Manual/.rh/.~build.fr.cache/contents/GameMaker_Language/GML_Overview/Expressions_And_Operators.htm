
  
  Выражения и операторы
  Выражение - это математическая фраза, которая может содержать обычные числа, переменные, строки или функции, а также один или несколько операторов (таких как сложение, вычитание, умножение и т.д...). Значения, используемые в выражении, могут быть вещественными числами
    (например, 3.4 * 6), шестнадцатеричные числа, начинающиеся со знака $ (например, $00FFAA | $88FFAA), строки между двойными кавычками (например, "hello" + "world") или более сложные выражения, использующие несколько операторов и значений.
  Для выражений существуют следующие операторы (в порядке приоритета):
   
  Присвоение (=)
  
    = - Используется для присвоения значения переменной. Обратите внимание, что это также может использоваться для сравнения переменных в GameMaker Studio 2, и вы можете увидеть это в примерах и чужих кодах. Однако это наследие старых GameMaker версии
      и вам следует использовать операторы == для сравнения и = для присвоения, как показано в этих примерах:
    a = 12; скорость = 5; val = (old_val + 5);
     
  
  Комбинирование (&&, ||, ^^)
  
    &&, ||, ^^ (and, or и xor) - объединяют булевы значения, чтобы получить либо true, либо false. Если любой из следующих примеров будет равен true, то код будет запущен:
    if (a == b && c == d) {do something...}  // и if (a == b || c == d) {do something...}   // или if (a == b ^^ c == d) {do something...}  // xor
     
  
  Сравнение (<, <=, ==, !=, >, >=)
  
    <, <=, ==, !=, >, >= - Это сравнения, которые могут дать только истинный или ложный результат ( где истинный может быть интерпретирован как 1, а ложный как 0). Примеры использования:
    if (a < b) {делайте что-нибудь...} if (a != b) {делайте что-нибудь...}
     
  
  Побитовые (|, &, ^, <<, >>)
  
    |, &, ^, <<, >> : С их помощью можно выполнять побитовые операции, где | = побитовое или, & = побитовое и, ^ = побитовое xor, << = сдвиг влево, >> = сдвиг вправо. Примеры использования:
    x = (x & $ffffffe0) + 32; if (y ^ $1f) > 0 {делаем что-нибудь...};
    Дополнительную информацию о том, как использовать побитовые операторы и что они делают, можно найти в разделе: Побитовые операторы.
     
  
  Арифметические (+, -, *, /)
  
    +, -, *, / - Сложение, вычитание, умножение и деление. Примеры использования:
    c = a * b; str = a + "world";
    ПРИМЕЧАНИЕ: Числа с плавающей запятой не останавливаются на делении на ноль, так как в качестве ответа они получат бесконечность. Если A и B - целые числа (либо int32, либо int64), то деление будет выполнено как целое число (и деление на 0 будет проверено и выдаст ошибку.
      В противном случае оно будет выполнено как деление с плавающей запятой (без проверки деления на 0).
     
  
  Увеличение/уменьшение (++, --)
  
    ++, --: Добавить или вычесть единицу из значения. Стоит отметить, что размещение этого параметра до или после значения, к которому нужно прибавить или из которого нужно вычесть, даст немного разные результаты. Например:
    
      ++a увеличит переменную и вернет увеличенное значение.
      a++ увеличит переменную, но вернет значение, которое было до ее увеличения.
    
    Поэтому, если у вас есть что-то подобное:
    var a = 1; show_debug_message(string(a++));
       show_debug_message(string(++a));
    
    Отладочный вывод будет иметь значения 1 и 3. Вот несколько примеров использования:
    for (var i = 0; i < 10; i++;) { сделайте что-нибудь... };
    if (hit == true) { --score; }
    ПРИМЕЧАНИЕ: На целевых платформах YoYo Compiler (отмеченных (YYC)) эти выражения оцениваются слева направо, в то время как на всех других целевых платформах они оцениваются справа налево, что означает, что это:
    val = max(num, ++num, num++);
    даст разные результаты в зависимости от платформы.
     
  
  Деление и модуль (div, %, mod)
  
    div, mod (%) - Деление и модуляция, где div дает сумму, на которую можно разделить значение, получив только целочисленный коэффициент, а mod дает только остаток от деления. Обратите внимание, что делить и модулировать можно только целые значения.
      Примеры использования:
    secs = time mod 60; time_str = string(time div 60);
     
  
  Унарные (!, -, ~)
  
    Также существуют следующие унарные операторы:
    
      !: булево "не", поэтому !true == false
      - : отрицает следующее вещественное или целочисленное значение (не действует для строк или булевых чисел)
      ~: побитово отрицает следующее значение
    
     
  
   
  В качестве значений во всех выражениях можно использовать числа, переменные или функции, возвращающие значение, а подвыражения можно заключать в скобки. Все операторы работают со значениями вещественных чисел, но сравнение также работает со строками, а оператор
    оператор " +" можно использовать для объединения строк.
  При выполнении нескольких операций в одном выражении очень важно использовать скобки () для разделения порядка операций, так как разные платформы могут выполнять их по-разному, если это не указано явно.
    таким образом. Например, рассмотрим следующий код:
  a = b == c || d;
  Различные целевые компиляторы будут выполнять операции в разном порядке, поскольку они не показаны явно, что приведет к "странным" результатам, которые вы можете не ожидать, играя в свою игру. чтобы избежать этого, используйте () для разделения частей, например, так:
  a = (b == c || d); //лучший a = ((b == c) || d); //лучший
  Также обратите внимание, что при использовании различных операций и выражений в одном блоке кода их тоже следует разделять. Например, следующий код выглядит как правильный:
  если my_var == your_var ++their_var;
  Однако компилятор может интерпретировать это одним из двух способов:
  if my_var == your_var++ then their_var;
     // или
     if my_var == your_var then ++their_var;
  Теперь, глядя на код, можно сказать, что один из них немного глуповат, но это потому, что мы знаем, чего хотим добиться и что должно произойти, а компилятор - нет. Все, что он видит, это две переменные с оператором ++ между ними.
    и ему приходится выбирать, к какой из них его применить. Поэтому всегда следует явно заключать в скобки выражения, операции и утверждения. Правильная версия приведенного выше кода должна быть следующей:
  if (my_var == your_var) {
     ++свой_вар;
     }
  
  Это может показаться более многословным, но в этом случае нет никакой двусмысленности в отношении выполняемых операций, и он будет компилироваться и вести себя последовательно на всех платформах. Также обратите внимание, что хотя вы можете объединять выражения и утверждения в цепочки без использования скобок
    в настоящее время это унаследованная функция, и в будущем она может быть устаревшей и удалена из GML, поэтому использование скобок сейчас позволит "защитить" ваш код от будущего (и в любом случае является хорошей практикой).
  Вот несколько последних примеров различных выражений:
  { x = 23 div 2; color = $FFAA00 + $00BB12; str = "hello" + "world"; y += 5; x *= y; x = y << 2; x = 23 * ((2 + 4) / sin(y)); b = (x < 5) && !((x == 2) || (x == 4)); }
  
  И последнее, что следует отметить, - это то, что для использования с определенными структурами данных и массивами существуют "короткие пути" выражения, называемые аксессорами.
    Они позволяют быстро и легко добавлять или заменять данные в этих форматах без использования каких-либо вызовов функций. Более подробную информацию можно найти на следующей странице
  
    Аксессоры
  
   
   
   
  
    
      
        Назад: ОбзорGML
        Следующий: Аксессоры
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

