
  
  Воспроизведение аудио
  Это событие может быть вызвано только функциями воспроизведения аудиоочереди и возвращает карту DS, хранящуюся в переменной  async_load,
    содержащую различные пары ключ/значение, относящиеся к аудиоочереди, которая вызвала событие. Событие запускается обратным вызовом, когда вы выбрали аудиоочередь для воспроизведения и
    буфер в этой аудиоочереди закончил воспроизведение.
  В карте DS будут доступны следующие клавиши:
  
    "queue_id" - индекс очереди, которая закончила воспроизведение, возвращаемый функцией audio_create_play_queue().
    "buffer_id" - идентификатор буфера , из которого прекращено воспроизведение.
    "queue_shutdown" - устанавливается на 0 при обычном воспроизведении и на 1, когда событие получено, потому что audio_free_play_queue() был
      было вызвано. Когда это значение установлено в 1, вы не хотите ставить в очередь дальнейшие данные.
  
  Поскольку аудио очередь может быть создана из нескольких буферов, это событие может быть вызвано несколько раз для одной очереди по мере достижения конца каждой секции буферизованного аудио, отсюда и ключ "buffer_id".
  ПРИМЕЧАНИЕ: Переменная async_load действительна только в асинхронных событиях, поскольку карта DS, на которую она указывает, создается в начале события, а затем удаляется в конце, при этом данная переменная сбрасывается со значением -1.
    Однако все дальнейшие структуры данных, созданные в результате события, должны быть очищены с помощью соответствующих функций.
  В примере использования, приведенном ниже, мы создадим аудио очередь с 10 буферизованными аудио звуками, добавленными к ней, а затем воспроизведем очередь:
  audio_queue = audio_create_play_queue(buffer_s16, 11052, audio_mono); for (var i = 0; i < 10; i++;) { audio_queue_sound(audio_queue, audio_buffer[i], 0, buffer_get_size(audio_buffer[i])); }  audio_play_sound(audio_queue,
    0, true);
  Теперь каждый шаг игры при обнаружении записи будет вызывать асинхронное событие Audio Recording, в котором вы сможете работать с записанным входом примерно так:
  var queue = async_load[? "queue_id"]; var num = 0; if queue = audio_queue { for (var i = 0; i < 10; i++;) { if async_load[? "buffer_id"] == audio_buffer[i] { buffer_seek(audio_buffer[i],
    buffer_seek_start, 0); num = i; }  }  if num == 9 { audio_stop_sound(audio_queue); audio_free_play_queue(audio_queue); }  }
  
  Здесь мы проверяем ID очереди, и если это та очередь, которая нам нужна, мы проверяем ID буфера, чтобы узнать, какой буфер закончил воспроизведение. Мы также устанавливаем локальную переменную в значение индекса для последующей проверки и возвращаем буфер в начало для этого звука.
    звука. Как только наша локальная переменная достигнет значения 9, что указывает на завершение очереди, мы остановим воспроизведение звука и освободим очередь.
   
   
   
   
  
    
      
        Назад: Асинхронные события
        Следующий: Аудиозапись
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

