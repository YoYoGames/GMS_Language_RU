
  
  События розыгрыша
  Категория событий Draw - это категория, в которой собраны все события, определяющие то, что вы видите на экране при запуске игры. Она разделена на различные
    отдельные события, чтобы лучше справляться с различными требованиями к рисованию в вашей игре, и на рисунке ниже показан порядок выполнения каждого события:
  Обычное событие Draw делится на три подтипа: Начало рисования, стандартное рисование и
   Draw End. В общем, вам понадобится использовать только стандартное событие Draw, и вы должны знать, что у всех экземпляров в комнате это событие будет срабатывать на каждом шаге игры, поэтому это событие будет вызываться всегда, пока
    пока у экземпляра флаг видимости установлен в true. Важно понимать, что даже если вы ничего не определили для этого подсобытия в свойствах объекта (т.е. нет ни кода, ни действий), если объекту назначен спрайт, у него все равно будет срабатывать событие рисования.
    Это происходит потому, что в GameMaker Studio 2 есть два способа рисования объектов в событии Draw:
  
     рисование по умолчанию, то есть когда вы определяете спрайт в свойствах объекта и не помещаете никаких действий или кода в обычное событие Draw, и в этом случае GameMaker Studio 2 будет рисовать назначенный спрайт автоматически. Обратите внимание, что любые преобразования
      которые вы выполняете в других событиях для изменения масштаба изображения, индекса, смешивания и т.д., также будут отражены, пока событие рисования пустое.
     пользовательское рисование, когда вы помещаете код или действия в событие рисования. Это говорит GameMaker Studio 2: "Я хочу управлять тем, что вы рисуете для экземпляров этого объекта", и полностью отменяет стандартное
      рисование. Это означает, что, например, вы можете иметь объект с назначенным спрайтом, затем установить событие draw на рисование текста, и текст будет нарисован на экране, но спрайт не будет нарисован, поскольку вы не сказали GameMaker Studio 2 
      рисовать его вместе с текстом.
  
  Остальные события розыгрыша объясняются в разделах, перечисленных ниже:
   
  Начало рисования и конец рисования
  
    Помимо основного события Draw, у вас также есть события  Draw Begin и Draw End. Они действуют точно так же, как и стандартные события Draw (т.е. они будут рисовать все, что вы поместите в них на каждом шаге игры и для
      но они не рисуют ничего "по умолчанию", если они не были явно добавлены к объекту, и всегда выполняются до/после стандартного события Draw. Таким образом, когда игра запущена, у вас всегда будет событие
      событие Draw Begin для всех экземпляров, затем событие Draw для всех экземпляров, и, наконец, событие Draw End для всех экземпляров.
    Таким образом, вы можете рисовать объекты или устанавливать свойства рисования на шаге Draw Begin в одном экземпляре и быть уверенным, что все экземпляры со стандартным событием Draw или Draw End будут использовать эти свойства или рисовать поверх того, что нарисовал первый экземпляр. По сути,
      это надежный способ гарантировать, что определенные вещи будут нарисованы в определенное время, подобно тому, как это делают события Begin Step и End Step .
    При рисовании в GameMaker Studio 2 необходимо учитывать несколько моментов, будь то спрайт, шейдер или 3D-буфер:
    
      Событие draw - это очень интенсивное событие, поскольку оно занимает больше всего времени и ресурсов... в связи с этим никогда не стоит делать в событии draw что-либо, кроме рисования. Поэтому приберегите свой большой код или сложные действия
        для события Step, Alarms или любого другого подходящего события, но оставьте событие draw для рисования, поскольку это то, что оно делает лучше всего.
      Если у вашего объекта параметр visible установлен в значение off (чтобы экземпляры объекта не рисовались), то все события рисования пропускаются (за исключением события Resize ). Это означает, что если сделать экземпляр
        невидимым, остановит выполнение всего кода, размещенного в любом из этих событий, поэтому не размещайте важный код в событиях рисования, если они не будут видимыми.
      То, что вы рисуете, не имеет никакого отношения к выбранному вами механизму столкновений (традиционному или физическому), поскольку это определяется свойствами объекта и спрайтом (или маской), который был предоставлен объекту.
    
     
  
  Нарисовать графический интерфейс пользователя
  
    Тип события Draw GUI относится к категории Draw Event и специально разработан для рисования элементов GUI, на которые не влияет масштаб или поворот камеры просмотра. Это означает, что вы
      что экземпляр может рисовать все элементы вашего HUD или пользовательского интерфейса без необходимости основывать позиционирование элементов на положении экземпляра в комнате или положении
      текущего вида камеры.
    При рисовании в этом событии важно понимать, что координаты рисования не меняются даже при активных видах камеры, а (0,0) всегда является верхним левым углом либо поверхности приложения, либо дисплея (см.
      примечание в нижней части этого раздела), а ширина и высота по умолчанию составляют 1:1 с поверхностью приложения. Упорядочение глубины сохраняется между экземплярами на разных слоях (поэтому экземпляр на более высоком слое будет рисоваться под
      один на более низком слое), а также внутри самих событий, так как событие Draw GUI Begin сначала отрисовывается для всех экземпляров, затем стандартное событие Draw GUI отрисовывается для всех экземпляров поверх него, и, наконец, событие Draw Gui End 
      срабатывает.
    Таким образом, вы можете рисовать объекты или устанавливать свойства рисования в Draw GUI Begin в одном экземпляре и быть уверенным, что все экземпляры со стандартным событием Draw GUI или Draw GUI End будут использовать эти свойства или рисовать поверх того, что нарисовал первый экземпляр. По сути,
      это надежный способ гарантировать, что определенные вещи будут нарисованы в определенное время, подобно тому, как это делают события Begin Step и End Step.
    Эти события также можно использовать вместе с обычными событиями Draw (на которые, как и на обычные, влияют положение, масштаб и вращение вида камеры). Если у вас нет события Draw Event, но есть событие Draw GUI Event, то GameMaker Studio 2 все равно
      по умолчанию нарисует спрайт для данного экземпляра (если он у него есть), как обычно.
    Что касается других событий рисования, то события Draw GUI всегда будут рисоваться поверх всего, что нарисовано в обычных событиях рисования. Таким образом, если у вас есть экземпляр на нижнем слое с событием Draw GUI, он будет рисоваться поверх экземпляра, который находится на более высоком слое
      с обычным событием рисования. Если оба экземпляра имеют событие Draw GUI, то порядок слоев будет соблюден.
    ПРИМЕЧАНИЕ: Это событие по умолчанию будет рисовать 1:1 с размером поверхности приложения, который обычно является размером комнаты или порта просмотра. Это означает, что если у вас включена коррекция соотношения сторон в опциях игры
      графический интерфейс не будет рисоваться поверх черных полос, которые "обрамляют" игру. Это поведение можно отключить с помощью функции  display_set_gui_maximise() функция,
      и вы также можете зафиксировать событие GUI определенного размера, который затем будет автоматически масштабироваться в соответствии с размерами дисплея или поверхности приложения с помощью функции display_set_gui_size().
     
  
  До и после жеребьевки
  
    События Pre Draw и Post Draw относятся к категории Draw Event. Однако, в отличие от других событий Draw, эти события рисуют непосредственно в буфер дисплея, который будет иметь размер
      объединенного пространства экрана для всех видовых экранов, видимых в данный момент, или размер окна, если используется только один видовой экран или вообще не используется. Изображение ниже иллюстрирует это:
    Итак, если вы используете события Pre или Post draw, вы рисуете в полноэкранную цель рендеринга (буфер дисплея), которая будет иметь
      тот же размер, что и окно, под которое подгоняются все видовые экраны. Если у вас нет активных видовых экранов, то вместо этого устанавливается размер самого окна.
    Событие Pre Draw запускается перед любым другим событием рисования, и в нем вы можете устанавливать значения, задавать свойства рисования и даже рисовать, не заботясь о видовых экранах или размере слоя GUI (размер слоя GUI может быть таким же, как экранный
      буфер, но это может быть и не так, поскольку вы можете установить разрешение GUI в коде).
    Стоит отметить, что это событие происходит до того, как буфер дисплея будет очищен для обычного рисования, а это значит, что если вы не отключите очистку вида в редакторе комнаты, то ничего из нарисованного в событии Pre Draw не будет видно, так как при
      первая отрисовка видового экрана очистит его. Если вы хотите иметь возможность видеть сквозь сами видовые экраны, или вы вообще не используете видовые экраны, то вам также следует установить цвет фона с альфа 0 в параметре Редактор комнат.
    ПРИМЕЧАНИЕ: Если вы отключите эти опции, вы можете заметить нежелательные артефакты, рисуемые на экране при тестировании игры (например, "следы" от инстансов). Это происходит потому, что вы рисуете прямо поверх предыдущего кадра
      буфера дисплея без его очистки. Однако вы можете использовать draw_clear_alpha() чтобы сделать это
      самостоятельно.
    Событие Post Draw запускается после всех стандартных событий рисования, но перед событиями Draw GUI. Как и событие Pre Draw, оно основано на размере буфера дисплея и помещается перед событиями Draw GUI, чтобы вы могли
      выполнять эффекты постобработки и другие вещи на весь экран просто и легко, не вмешиваясь в любые элементы HUD/ GUI.
      которые могут присутствовать в вашей игре.
     
  
  Изменение размера окна
  
    Этот тип события относится к категории событий Draw Event, и хотя на самом деле он ничего не рисует, он реагирует на изменения в буфере дисплея - в частности, он предназначен для реагирования на изменение размера буфера дисплея UWP при
      игровое окно "привязывается".
    На целевой платформе UWP важно уловить изменение размера буфера дисплея в результате "привязки" игрового окна (когда пользователь, например, перетаскивает окно в сторону дисплея). Это событие как раз для этого и
      срабатывает при каждом изменении окна, позволяя вам добавлять сюда пользовательский код, который будет изменять размер представления или позиционировать элементы HUD по мере необходимости. Эта функция предоставляется как удобный
      чтобы избежать необходимости постоянно проверять код события.
    ПРИМЕЧАНИЕ: Вы не можете рисовать в этом событии! Оно запускается при изменении размера окна и предназначено только для улавливания этого изменения... любое рисование, которое должно быть выполнено, должно быть выполнено в одном из других событий draw.
     
  
   
   
   
  
    
      
        Назад: События объекта
        Следующий: Асинхронные события
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

