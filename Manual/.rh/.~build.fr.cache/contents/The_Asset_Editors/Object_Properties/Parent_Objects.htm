
  
  Родительские объекты
  При работе с объектами в IDE GameMaker Studio 2 можно создавать иерархии родительских  и дочерних объектов. Для этого нужно нажать кнопку "Parent" в редакторе объектов, а затем выбрать другой объект из браузера ассетов.
    который будет "родителем" редактируемого объекта:
  Итак, каждый объект в вашем игровом проекте может иметь родительский объект, но что это значит? Когда у объекта есть родительский объект, он может
    обмениваться кодом, действиями и событиями с этим родителем. Такой обмен называется "наследованием", а объект, у которого есть родитель, называется "дочерним". Дочерний объект не только может делиться кодом со своим родителем, но вы можете выполнять проверки и запускать код
    на родительских объектах, и он будет автоматически включать и дочерние объекты, что экономит много времени и энергии.
  Если это звучит сложно, то другой способ взглянуть на родительский объект - это способ "сгруппировать" объекты вместе под одним зонтиком, чтобы они разделяли определенные вещи, не теряя своей уникальной индивидуальности. Возможно, это все еще не
    проясняет ситуацию, поэтому давайте приведем несколько примеров...
  Допустим, у вас есть объект "игрок" и четыре различных объекта "враг". Теперь вы хотите, чтобы игрок умер, если он коснется любого из этих четырех объектов, и это обычно влечет за собой четыре различных события столкновения с четырьмя различными наборами
    действий или кода, по одному для каждого из вражеских объектов. Но если мы создадим родительский объект для всех врагов, то мы сможем создать одно событие столкновения только с родительским объектом, и оно сработает независимо от того, какой из четырех "дочерних" вражеских объектов коснется игрока.
    коснется игрока. Удобная штука! В реальном объекте GameMaker Studio 2 вы увидите примерно следующее:
  Слева у нас четыре отдельных события столкновения, а справа - одно событие столкновения, поскольку мы создали
    "родительский объект и назначили ему все вражеские объекты. Обратите внимание, что родительский объект не обязательно должен содержать какие-либо события или код...
  Другим примером родительского поведения может быть игра, в которой вы хотите создать 10 различных по внешнему виду объектов и заставить их всех вести себя одинаково. Для этого вы создадите один родительский объект и в нем все ваши поведенческие действия или код
    в необходимых событиях, а затем вы создадите десять объектов без действий и кода, но с разными спрайтами, и назначите их родительскому объекту. Теперь, когда вы поместите эти экземпляры в комнату, все они будут вести себя одинаково, но выглядеть по-разному,
    поскольку они "наследуют" события родительского объекта.
  Наконец, вы можете использовать воспитание, чтобы "смешивать и сопоставлять" события и поведение. Мы проиллюстрируем это на последнем примере... Допустим, вам нужны два монстра: один двигается вверх и вниз, а другой - влево и вправо.
    чтобы они имели одинаковое здоровье, стреляли в игрока и ранили игрока при столкновении с ними. В этом случае вы видите, что почти все события должны иметь одинаковые действия, за исключением одного или двух, которые управляют движением. Итак, опять же, мы можем сделать
    один объект родителем другого, но в этом случае мы также определяем определенные события для дочернего объекта. Эти события "отменяют" родительские события, что означает, что всякий раз, когда событие для дочернего объекта содержит действия, они выполняются
    вместо действий, содержащихся в событии родителя. Если вы также хотите выполнить родительское событие, вы можете вызвать так называемое "унаследованное" событие с помощью функции event_inherited(),
    или действие DnD™ Call Parent Event.
  Слева вверху находится родительский объект с 5 событиями в нем, а справа вы видите "дочерний" объект. Дочерний объект
    также имеет 5 событий, но два из них переопределяют унаследованные от родителя события (события Step и Draw ), а три других выделены серым цветом, так как они являются событиями, унаследованными от родителя. Унаследованные события
    также будут иметь значок "переопределение родителя" рядом с ними в редакторе событий:
  Когда вы щелкаете  на событии, которое было унаследовано,
    откроется редактор кода, в котором будет показан унаследованный родительский код, но вы не сможете редактировать этот код, так как его можно редактировать только в самом родительском объекте. Вы можете нажать правую кнопку мыши  на любом из родительских событий, чтобы открыть следующее меню опций:
  Здесь вы можете выбрать два варианта Открыть родительское событие, чтобы просмотреть код, или выбрать Наследовать событие или Переопределить событие.
    событие или переопределить событие. Если вы выберете Наследовать , то редактор кода откроется с функцией event_inherited() уже
    (или действием Call Parent Event, если вы используете DnD™). Любой дальнейший код, который вы поместите в это событие, теперь будет выполняться так же, как и код родительского объекта.
    имеет. Если вы выберете Переопределить событие, то окно кода также откроется, только теперь функция event_inherited() не будет вызываться, поэтому все, что вы добавите сюда, будет выполняться вместо кода
    в родительском объекте.
  ПРИМЕЧАНИЕ: Из редактора кода вы можете быстро перейти к родительскому объекту, нажав правую кнопку мыши  и выбрав Go To Object из всплывающего меню, или (если событие было переопределено) вы можете выбрать Open Inherited Event, чтобы перейти непосредственно в редактор кода с кодом родительского события в нем.
  Когда в коде вы нацеливаетесь на родительский объект, код будет применяться и к "детям" родительского объекта. Это происходит, когда в действии вы указываете, что действие должно быть применено к экземплярам определенного объекта, а в коде это
    происходит, когда вы используете with() оператор. Это будет работать и при вызове функций кода, таких как instance_position(),
    instance_number(), и т.д., где - если вы предоставите родительский объект - все экземпляры родительского и дочернего экземпляров
    будут включены в проверку. И наконец, родительские функции работают, когда вы ссылаетесь на переменные в других объектах, как в приведенном выше примере с монстром, если я установлю скорость врага 1 равной 10, то скорость врага 2 также будет равна десяти, поскольку он является дочерним объектом врага
    1.
  Обычно считается хорошей практикой в большинстве случаев создавать один базовый родительский объект, чтобы этот базовый объект содержал все поведение по умолчанию, но никогда не использовать его экземпляр в игре. Лучше использовать все дочерние объекты и использовать родительский объект только в ситуациях, подобных тем, которые я описал выше.
    ситуациях, подобных тем, что я описал выше, для столкновений, для ссылок на переменные и т.д... Вы также должны понимать, что у родителей тоже могут быть родители! Очевидно, что вы не можете создать цикл "родитель 1 является ребенком родителя 2 является ребенком родителя
    1", но вы можете создать так называемую "иерархию объектов", где "родитель 3 является ребенкомродителя 2 является ребенком родителя 1" . Это чрезвычайно полезно для структурирования вашей игры, и вам настоятельно рекомендуется
    научиться использовать этот механизм.
   
   
   
  
    
      
        Назад: Редактор объектов
        Следующее: Физические объекты
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

