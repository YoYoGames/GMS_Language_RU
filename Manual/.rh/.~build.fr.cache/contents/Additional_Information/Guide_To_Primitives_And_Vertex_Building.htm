
  
  Руководство по примитивам и построению вершин
  Это руководство кратко описывает, как создавать и использовать примитивы, используя пользовательские форматы вершин и вершинные буферы. 
  Обычно, когда вы начинаете работать с 3D, спецэффектами, сложными процессами рисования или шейдерами, вам не нужно слишком беспокоиться об используемом формате вершин, поскольку GameMaker Studio 2 автоматически установит и передаст вершинные данные за вас. Однако иногда необходимо создать собственные вершинные данные и отформатировать их в соответствии с требованиями, особенно если вам нужно увеличить скорость или передать дополнительную информацию. Например, стандартный
    формат вершин включает в себя x, y, z 3D позицию, цвет (с альфа) и UV координаты текстуры, которые, если бы вы создавали их самостоятельно, выглядели бы примерно так:
  vertex_format_begin(); vertex_format_add_position_3d();
     vertex_format_add_colour();
     vertex_format_add_textcoord();
     my_format = vertex_format_end();
  Однако если вы используете (например) шейдер только для манипулирования положением вершины, то нет необходимости передавать данные цвета или текстуры. В этом случае вы создадите свой собственный формат следующим образом:
  vertex_format_begin(); vertex_format_add_position_3d();
     my_format = vertex_format_end();
  Всего существует пять различных атрибутов вершин, которые можно использовать при определении формата вершин:
  
    Цвет
    Нормальный
    Позиция
    3D-позиция
    Координата текстуры
  
  В общем случае вы всегда должны указывать позицию или 3D-позицию как часть формата, но все остальные параметры являются необязательными.
  Следует отметить, что после создания формата вершин, порядок, в котором вы определили атрибуты вершин, должен соблюдаться при построении примитивов. Так, если вы определили формат вершины как позицию, цвет,
    и текстурная координата, то вы должны добавить эти атрибуты в примитив в том же порядке, иначе вы получите ошибку. Также обратите внимание, что, как и любой другой динамический ресурс, формат вершины требует памяти и поэтому должен быть удален
    когда он не нужен, используя функцию vertex_format_delete().
  Все примитивы, которые вы создаете, хранятся в буфере вершин. Он должен быть создан заранее, а затем на него ссылаются функции, которые используются для создания вашего примитива. Буфер вершин можно использовать повторно столько раз, сколько необходимо для создания различных
    или его можно "заморозить", чтобы сохранить определенный тип примитива на весь период игры или уровня (это самый быстрый подход, поэтому если вы знаете, что созданный вами примитив не изменится, всегда используйте этот вариант).
  Пример построения примитива с одним треугольником показан в следующем коде:
  // СОЗДАТЬ СОБЫТИЕ v_buff = vertex_create_buffer(); vertex_begin(v_buff, global.my_format); vertex_position(v_buff, 10, 10); vertex_colour(v_buff, c_white, 1); vertex_texcoord(v_buff, 0, 0); vertex_position(v_buff, 110, 10); vertex_colour(v_buff, c_white, 1);  vertex_texcoord(v_buff, 1, 0); vertex_position(v_buff, 110, 110); vertex_colour(v_buff, c_white, 1); vertex_texcoord(v_buff, 1, 1); vertex_end(v_buff);
    
     // DRAW EVENT var tex = sprite_get_texture(spr_Background, 0); shader_set(shd_shimmer);
     vertex_submit(v_buff, pr_trianglelist, tex); shader_reset();
  
  Здесь мы сначала создаем буфер вершин в событии Create экземпляра, затем начинаем определение различных вершин, составляющих наш треугольный примитив, указывая положение, цвет и UV-координаты текстуры для каждой из трех точек.
    трех точек, которые мы хотим использовать. Затем мы завершаем определение вершин и узнаем, что буфер вершин с данными вершин хранится в переменной "v_buff".  
  ПРИМЕЧАНИЕ: Если содержимое буфера будет постоянно обновляться, буфер будет создан, ему будут переданы данные вершин, а затем он будет снова уничтожен - после того, как будет отрисован - и все это на одном шаге.
  Затем мы отрисовываем содержимое буфера вершин в событии Draw Event с помощью шейдера. Это очень простой пример, и в основном GameMaker Studio 2 работает следующим образом: когда вы рисуете спрайт, GameMaker создает буфер вершин с четырьмя вершинами.
    создает два треугольника (которые образуют квадрат, также называемый "quad"), и текстурирует эти два треугольника изображением спрайта. Когда мы рисуем спрайт, мы передаем вершинный буфер, и его содержимое выводится на экран.
  Вы заметите, что когда мы передаем буфер вершин для отрисовки, мы предоставляем тип примитива. Тип используемого примитива может быть точкой, списком или полосой линий, списком или полосой треугольников, но вы не можете использовать веер треугольников, так как большинство мобильных устройств принимают этот тип примитива.
    аппаратное обеспечение не принимает этот тип примитива. Не забудьте правильно отформатировать вершинный буфер для типа примитива, который будет использоваться для его отрисовки. Например, рисование примитива с двумя треугольниками в виде списка треугольников требует 6 вершин,
    но в виде полосы треугольников требуется только 4 точки. Какой тип использовать - решать вам, это зависит от того, что вы хотите нарисовать, и от эффекта, которого вы хотите добиться.
  Последний важный момент, который следует отметить при использовании собственных вершинных буферов таким образом, - это то, как это влияет на пакеты вершин, которые отправляются на GPU. Когда вы создаете буфер вершин, вы создаете самый низкий уровень графических данных, поэтому при рисовании все, что происходит, это то, что GameMaker Studio 2 отправляет ваш буфер непосредственно в GPU.
   GameMaker Studio 2 отправляет ваш буфер непосредственно на видеокарту. Поэтому, если вы хотите улучшить пакетную обработку, вы должны сделать это самостоятельно и хранить то, что вы хотите пакетно обрабатывать, в одном и том же буфере.
  Как мы уже говорили выше, вершинные форматы строятся с помощью следующих 5 типов атрибутов (добавляются с помощью соответствующей функции vertex_format_add_* ):
  
    Цвет
    Нормальный
    Позиция
    3D-позиция
    Координата текстуры
  
  В шейдере GLSL ES эти виды распознаются с помощью следующих 4 атрибутов:
  
    Цвет
    Нормальный
    Позиция
    Координата текстуры
  
  Теперь это может показаться странным, так как кажется, что мы можем указать больше видов атрибутов в нашем вершинном формате, чем в вершинном шейдере. Однако в шейдере Position и 3D Position рассматриваются как один и тот же атрибут, за исключением того, что
    Предполагается, что Position имеет только координаты "x" и "y", в то время как 3D Position имеет координаты "x ", "y" и "z". Как же сопоставить то, что находится в вашем формате вершин, с тем, как вы определяете атрибуты в шейдере ? Давайте
    начнем с рассмотрения типичного набора атрибутов из шейдера по умолчанию:
   
  attribute vec3 in_Position; // (x,y,z) //attribute vec3 in_Normal; // (x,y,z) не используется в этом шейдере. attribute vec4 in_Colour; // (r,g,b,a) attribute vec2 in_TextureCoord; // (u,v)
  А вот фрагмент кода, который устанавливает формат вершин , совместимый с этим шейдером:
  vertex_format_begin(); vertex_format_add_position_3d();
     vertex_format_add_colour();
     vertex_format_add_textcoord();
     my_format = vertex_format_end();
  Итак, как атрибут шейдера сопоставляется с видом вершинного формата? Это просто основано на соглашении об именовании:
  
    "in_Position" соответствует vertex_format_add_position / _3d()
    "in_Colour" соответствует функции vertex_format_add_colour ()
    
    "in_TextureCoord" соответствует функции vertex_format_add_textcoord ()
      
    
  
  
    Теперь все становится сложнее, когда у вас есть несколько атрибутов одного типа, но все равно все основано на одном и том же соглашении об именовании. Теперь мы рассмотрим предоставление дополнительных координат цвета и текстуры, поскольку в шейдере или вершинном формате может быть только один атрибут Position и один Normal, но может быть несколько атрибутов цвета или текстуры.
  При добавлении дополнительных цветовых атрибутов в шейдер к концу атрибута шейдера необходимо добавить число, указывающее, к какой именно записи вершинного формата относится атрибут. Вот пример - сначала формат вершин:
  vertex_format_begin(); vertex_format_add_position_3d();
     vertex_format_add_colour();
     vertex_format_add_colour();
     vertex_format_add_textcoord();
     my_format = vertex_format_end();
  А теперь связанные атрибуты шейдера:
  attribute vec3 in_Position; // (x,y,z) attribute vec4 in_Colour0; // (r,g,b,a) attribute vec4 in_Colour1; // (r,g,b,a) attribute vec2 in_TextureCoord; // (u,v)
  В этом случае in_Colour0 используется для первой вершины vertex_format_add_colour(), а in_Colour1 - для второй.
  Координаты текстуры обрабатываются несколько иначе, чем цвет. В основном, все, что не называется in_Position , in_Normal или одним из атрибутов in_Colour [0 ... ], рассматривается как координата текстуры. Порядок, в котором они
    в списке атрибутов в шейдере, обозначает, с каким атрибутом в вершинном формате они связаны. См. следующий пример GML:
  vertex_format_begin(); vertex_format_add_position_3d();
     vertex_format_add_colour();
     vertex_format_add_textcoord();
     vertex_format_add_textcoord();
     vertex_format_add_textcoord();
     my_format = vertex_format_end();
  А код шейдера будет выглядеть примерно так:
  attribute vec3 in_Position; // (x,y,z) attribute vec4 in_Colour; // (r,g,b,a) attribute vec2 in_myTexcoord; // (u,v) attribute vec2 in_TextureCoord; // (u,v) attribute vec2 in_Something; // (u,v)
  В этом примере in_myTexcoord, in_TextureCoord и in_Something отображаются на три последовательных атрибута текстурных координат, определенных в формате вершин.
  Полный список всех функций, необходимых для создания вершинных форматов, вершинных буферов и примитивов, можно найти на следующей странице:
  
    Примитивы и форматы вершин
  
   
   
   
  
    
      
        Назад: Дополнительная информация
        Следующее: Руководство по использованию блендмодов
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

