
  
  Побитовые операторы и двоичные
  В начале компьютерной эры двоичные и шестнадцатеричные (шестнадцатеричные) числа были образом жизни, вероятно, потому, что языки высокого уровня (такие как BASIC) были слишком медленными для работы. Например, умножение 32 x 32 могло занять
    несколько тактов процессора, чтобы выполнить его с помощью BASIC, но в двоичной системе это делается как одна операция за один такт процессора.
  Однако в наши дни, с мощностью даже базового ПК, вам больше не нужно беспокоиться об этом, и вы можете делать вещи "длинным путем", поскольку скорость машины и ее более сложная конструкция процессора компенсируют любые недостатки этого подхода.
    недостатки этого подхода. Конечно, это отличная новость, поскольку она означает, что вам больше не придется оптимизировать каждую строчку написанного кода, но если это так - стоит ли вообще заботиться о двоичном коде?
  Ответ определенно "да, стоит". Хотя это правда, что вы все еще можете получить некоторое увеличение скорости - и иногда оно может быть значительным - использование двоичного и шестнадцатеричного кода приводит к лучшему пониманию того, как работает процессор, а также может привести к написанию
    лучший код, возможность лучше упаковывать данные и значительно упростить некоторые задачи. На этой странице мы немного расскажем о том, что такое двоичный код, а также о том, как его можно использовать при создании игр.
  Итак, давайте сначала рассмотрим самую основную теорию двоичных чисел - как создаются числа. Взгляните на эту таблицу:
  000 = 0 001 = 1 010 = 2 100 = 4
  Каждая 1 или 0 представляет собой один бит данных, и, как вы видите, это означает, что в двоичном исчислении 10 равно 2! Каждый бит в 2 раза больше предыдущего значения, причем первый бит равен 1. Таким образом, бит 2 = 2,
    бит 3 = 4, бит 4 = 8 и так далее (как показано ниже в таблице байтов ):
  00000001 = 1 00000010 = 2 00000100 = 4 00001000 = 8 00010000 = 16 00100000 = 32 01000000 = 64 10000000 = 128
  Это хорошо, если вам нужны числа, равные степени 2, но как создать более сложные числа? Одно двоичное число может хранить только 0 или 1, и это все, поэтому для создания более сложных чисел нам нужно складывать биты. Если, например, мы
    хотим получить 6, мы складываем 4 и 2 вместе следующим образом.
  00000010 = 2 00000100 = 4 00000110 = 6
  Это относится ко всем двоичным числам и к тому, как компьютер составляет любое число внутри себя. В качестве примера возьмем более сложное число: 23. Число 23 на самом деле состоит из 1+2+4+16 или 00010111. А как насчет гораздо более сложного примера: 196? Ну, это число состоит из 128+64+4 или 11000100. Так что на самом деле все не так уж и сложно!
  Если мы начинаем использовать значения вне диапазона байта (который может хранить числа от 0 до 255), отследить их становится немного сложнее. Например, 217 361 - это 110101000100010001 в двоичном формате. Или 1+16+256+etc... Правила одинаковы независимо от того, какое значение выражается - каждое число создается путем сложения нескольких битов.
  Теперь, как нам выполнить математические операции над этими значениями? Допустим, вы хотите сохранить true или false в качестве значения. Обычно компиляторы используют INT (an
    INT обычно определяется как знаковое 32-битное число - знаковое означает, что оно может быть положительным или отрицательным, а беззнаковое означает, что оно может быть только положительным), а затем просто присваивают его 0 или 1.
      Имея только 2 состояния, значение true / false идеально хранить в бите, и если мы сделаем это, то сможем хранить 32 бита true / false для каждого из них.
      INT , а не только один, поскольку INT состоит из 32 битов.
  Как бы мы это сделали? Оказывается, довольно легко:
  флаги = флаги | 1;
  Оператор "|" является побитовым OR, и это означает, что приведенная выше инструкция ORs 1 в значение, хранящееся в переменной flags. Если вы
    помните из предыдущего, использование 1 установит первый бит. Если бы мы хотели установить второй бит, мы бы сделали следующее:
  флаги = флаги | 2;
  Мы OR в 2, потому что битовый шаблон 00000010 равен 2. Что же именно делает двоичный оператор OR? Ну, он объединяет все биты в одно значение,
    вот так:
  010110100 // Значение 1 110011001 // Значение 2 110111101 // Значение 1 ИЛИ Значение 2
  Вот что известно как таблица истинности для оператора OR:
  00 | 00 = 00 00 | 01 = 01 01 | 01 = 01 01 | 00 = 01
  Поэтому там, где есть значение с двумя нулями, оно останется нулем. Преимущество использования таких битов в качестве true/false состояния заключается в том, что вы можете установить несколько битов в качестве "флагов" за одну операцию,
    что невозможно сделать с обычным булевым значением. Например, допустим, бит 1 - это "активный" флаг, а бит 3 - "видимый" флаг. Мы можем установить оба флага следующим образом:
  флаги = флаги | 5;
  Это происходит потому, что 5 - это 00000101 в двоичном формате, и, следуя вышеприведенному правилу, переменная "flags" получит оба этих бита, объединенных с ее собственными. Поэтому даже если бит 1 уже был установлен, операция все равно сработает, и бит 3 будет
    теперь также будет установлен.
  А как насчет очистки флагов? Вот тут-то и приходит на помощь побитовая операция "&" AND. Когда вы AND что-то делаете, биты, установленные в маске, сохраняются,
    а биты, которые очищены в маске, удаляются - вот так:
  0111001010101 // Значение 1 00110000100 // Значение 2 00110000100 // Значение 1 И значение 2
  Как вы видите, там, где в каждом значении есть 1, 1 сохраняется, а там, где есть смесь 0 и 1, они сбрасываются в 0. Вот таблица истинности для ANDing:
  00 & 00 = 00 01 & 00 = 00 00 & 01 = 00 01 & 01 = 01
  Таким образом, только когда в каждом месте есть бит, он будет сохранен. Это означает, что так же, как вы можете установить несколько флагов одновременно, вы можете и очистить несколько флагов одновременно. Например, возьмем приведенный выше случай, но на этот раз очистим их.
    Мы хотим очистить биты 1 и 3 (получив значение 5), но, вспоминая таблицу истинности выше, мы хотим оставить все остальные биты, а биты 1 и 3 очистить. Это будет двоичная "маска" 111111111111111111111111111111111010 (32 бита).
    Эта маска сохраняет все биты установленными, но очищает два бита, которые мы хотим очистить. Таким образом, если значение 1000111011 и я хочу очистить биты 1 и 3, используя вышеуказанную маску, это будет выглядеть следующим образом...
  000000000000000000000000001000111011 // Значение 11111111111111111111111111111111111010 // Маска 000000000000000000000000001000111010 // Значение и маска
  Это здорово, но если бы нам приходилось делать это каждый раз, когда нам нужно очистить флаги, это стало бы утомительным. Нам нужен способ легко переключать биты (и желательно без затрат процессора). К счастью, есть простой способ сделать это с помощью оператора "
    ~ " NOT оператор.
  Оператор NOT - это именно то, что он говорит - не эти биты. Вот таблица истинности для NOT.
  ~00 = 11 ~01 = 10 ~10 = 01 ~11 = 00
  Этот оператор делает удаление флагов очень простым, и что еще лучше, обычно это оптимизация во время компиляции, то есть если вы используете постоянное число (то есть не переменную), то компилятор автоматически перевернет биты. Возьмем следующее утверждение
    где мы хотим снова очистить биты 1 и 3:
  a = a & ~5;
  На самом деле это будет компилироваться просто как "a & 11111111111111111111111111111010". Это делает жизнь довольно простой в плане очистки флагов.
  Последний оператор, который мы хотим рассмотреть, это "^" EOR (Exclusive OR, иногда называемый XOR), этот оператор переворачивает биты, установленные в обоих
    значения. Вот таблица истинности EOR:
  0 ^ 0 = 0 0 ^ 1 = 1 1 ^ 0 = 1 1 ^ 1 = 0
  Это любопытная, но невероятно полезная функция. Например, допустим, нам нужен счетчик, который просто считает от 0 до 1 и обратно до 0 (переключаясь между 0 и 1), мы можем добавить один и сделать IF, чтобы увидеть, дошел ли он до значения
    2, а затем сбросить его обратно в 1. Или... мы можем добавить 1 и затем AND его с 1 (так как 01+01 = 10, и 10 & 01 = 0) или мы можем сделать вот так:
  a = a ^ 1;
  При первом запуске 0 ^ 1 = 1, при втором 1 ^ 1 = 0, таким образом, происходит переключение с 0 на 1.
  Итак - OR (|), AND(&), NOT(~) и EOR(^)
    позволяют нам манипулировать битами с относительной легкостью, позволяя нам, на самом простом уровне, управлять несколькими битами одновременно. Очевидно, что при разработке игр мы можем использовать эти операции для других целей, например, для маскировки спрайтов, выполнения целочисленных операций MOD (используя AND) или создания красивых циклических счетчиков.
  Итак, мы можем выполнять простые побитовые операции, но давайте рассмотрим более сложные вещи, начиная с вопроса, как компьютер складывает? Давайте рассмотрим очень простой пример: 1+1.
  00000001 00000001
     00000010
  
  Как и при обычном сложении, мы складываем числа вместе, а затем переполняем следующий столбец, но в отличие от обычного десятичного сложения, мы можем переходить только от 0 к 1, а не от 0 к 9. Таким образом, добавление 1+1 означает переполнение в 10.
    Давайте рассмотрим более сложный пример.
  01011011 = 91 00101101 = 45 10001000 = 136
  Очевидно, что здесь это сложнее увидеть, но переполнения пульсируют до тех пор, пока в столбце не останется ни одной единицы. Стоит отметить, что компьютеры могут складывать (или вычитать, умножать или делить) только 2 числа одновременно. Возьмем 19 + 19 + 19.
    Будучи людьми, мы можем сложить все 9 вместе, перенести 2 и продолжить! Но компьютеры не могут этого сделать - они могут сделать вот что: (19 + 19) + 19. Поэтому они будут выполнять каждое вычисление блоками по 2.
  Двоичные вычисления, которые представляют наибольший интерес для нас, программистов, - это умножение и деление. Компьютеры умножают только на 2, а чтобы сделать больше, они разбивают число на части, а затем складывают все результаты вместе. Давайте рассмотрим несколько очень простых
    примеры. 4 * 2 = 8. Чтобы умножить на 2 в двоичном формате, мы сдвигаем все биты влево на единицу. Вот так:
  00000100 * 2 = 00001000 = 8
  В этом случае все биты сдвинулись влево на единицу, в результате чего число переместилось из 3-го бита в 4-й и изменило значение с 4 на 8. Как насчет большего числа?
  101 = 01100101 * 2 = 11001010 = 202
  Опять же, все биты сдвигаются на единицу, и это умножается на 2. Итак, как насчет умножения на 4? Легко, мы сдвигаем все влево на 2, а не на 1. Так как насчет 16 или 128? Это потребует сдвига влево на 4 или 7 бит соответственно. Это невероятно
    полезно; это означает, что мы можем выполнять простые умножения, просто перемещая биты. Для этого мы используем оператор сдвига влево <<. Вот несколько примеров:
  00000001 << 1 = 000000010 = 2 00000001 << 2 = 000000100 = 4 00000001 << 3 = 000001000 = 8 00000001 << 4 = 000010000 = 16 00000001 << 5 = 000100000 = 32 00000001 << 6 = 001000000 = 64 00000001 << 7 = 010000000 = 128 00000001 << 8 = 100000000 = 256
  Теперь, помимо того, что это очень полезно для быстрого/простого умножения, это также очень полезно для установки определенных битов, без необходимости выяснять значение бита. Допустим, мы хотим установить бит 27, какое это число? (67108864, кстати!), что ж
    мы можем использовать приведенный выше синтаксис, чтобы легко установить такие флаги:
  a = a | (1 << 27)
  Хорошо... на самом деле это будет бит 26, как мы описывали до сих пор (поскольку биты начинаются с единицы), но на самом деле... биты начинаются с бита 0 и идут вверх, а не с бита 1. Поэтому, хотя в ИНТЕГЕРЕ 32 бита, биты начинаются от
    от 0 до 31, а не от 1 до 32. На самом деле это довольно полезно, поскольку теперь мы можем задавать константы для битовых чисел.
  Допустим, бит 27 - активный флаг, а бит 0 - флаг взрыва. Как мы можем установить оба?
  ACTIVE = 27; BOOM = 0; A = A | (1 << ACTIVE) | (1 << BOOM);
  Это может показаться большим количеством кода, но если эти числа являются константами, компилятор предварительно соберет эти операции в одно значение, так что в итоге мы получим вот такой код.
  A = A | 13421772;
  Очистка этих битов (как мы видели выше) - это просто использование модификатора NOT, например, так:
  A = A & ~((1 << ACTIVE) | (1 << BOOM));
  Таким образом, это позволяет нам устанавливать и очищать любые биты, а также значительно сжимать структуры данных. Сжатие структур данных - это хорошо, потому что если вы используете меньше памяти, вы получаете меньше промахов кэша, и ваш код просто работает быстрее.
    быстрее. Скажите, что быстрее - копировать 32 Мб данных или 4 Мб? Совершенно очевидно, что 4. Так что если вы можете упаковать все свои флаги в один доступ к памяти, это хорошо!
  Теперь давайте вкратце рассмотрим, как выполняется деление, и почему это будет так полезно. Деление выполняется путем сдвига битов вправо с помощью оператора сдвига вправо >>. Давайте возьмем
    простое число - 64 - и разделим его на 32:
  64 / 32 = 01000000 >> 5 = 00000010
  Таким образом, вы сдвигаете единственный бит вниз на 5 (это количество сдвигов, необходимое для 32 - см. выше), что дает нам 2. Но что произойдет, если здесь есть другие биты? Давайте посмотрим:
  68 / 32 = 01000100 >> 5 = 00000010
  Так что вот, пожалуйста.... Все точно так же. Биты, которые мы сдвигаем вниз, просто теряются. На самом деле это очень полезно, потому что при делении вниз, если нам нужен остаток, есть еще более простой способ его получить, к которому мы перейдем через некоторое время. Но
    сначала давайте рассмотрим практический пример. У меня есть позиция X и Y, и я хочу получить ячейку сетки, в которую она попадает, где сетка имеет размер 32x32. Этот метод позволяет хранить объекты, столкновения, флаги - всевозможные вещи, и получать к ним доступ
    очень быстро. Итак, начнем:
  var X_index = x >> 5; var Y_index = y >> 5; cell_data = mygrid[# X_index,Y_index];
  Итак, что если нам нужен остаток? Возможно, этот остаток используется как некий флаг порядка или что-то в этом роде. Какова бы ни была причина, получить остаток так же просто, как выполнить AND:
  var remainder = x & 31 var X_Index = x >> 5;
  Теперь вы, наверное, заметили, что мы использовали несколько строк кода (как это часто бывает), но это все равно всего лишь пара очень быстрых инструкций. Но почему именно 31? Так как бит 5 равен 32, то все биты ниже будут равны 31, а это
    максимальный остаток, поэтому мы используем AND (мы также можем использовать (1 << 5) - 1, в результате чего получится 32 - 1 = 31). Теперь, если бы я делал это без понимания
    двоичной системы, это выглядело бы следующим образом:
  var r = x mod 32; var X_Index = floor(x / 32);
  Почему же это намного хуже? Чтобы разделить на 32, мы должны выполнить деление с плавающей запятой - что, очевидно, занимает время, но для того, чтобы сделать mod 32, нужно выполнить еще одно деление! Если бы мы делали это
    на ассемблере, мы действительно получили бы ОБА значения за одно деление, но в языках высокого уровня такого не бывает (ну... не очень часто), и поэтому приходится выполнять всю работу дважды. Это увеличивается, особенно если вы делаете узкий цикл с большим количеством вычислений.
    например. Целочисленные деления с использованием сдвига битов, как показано выше, действительно помогают оптимизировать вашу игру.
  Поскольку эта концепция может быть довольно сложной для понимания и последующего применения в реальных ситуациях программирования, ниже вы найдете серию коротких примеров, которые могут быть применены к любой игре, созданной с помощью GameMaker Studio 2.
  Выравнивание плитки
  
    РазработчикиGameMaker Studio 2 часто используют функцию place_free(), а затем, когда обнаружено столкновение, пытаются медленно вывести объект, либо обходя по кругу позиции x или y, продолжая выполнять эту функцию, либо используя функцию move_outside_all().
    Итак, какой способ сделать это быстрее? Ну, если мы используем правильную мощность 2 плиток, то у нас есть очень простой метод, который также является молниеносным. Если мы движемся вправо и попали в блок столкновений, то, как мы знаем, все выравнивается по 32.
      выравнивается по 32, поэтому нам нужно также выровнять спрайт по 32-пиксельной границе - предпочтительно по левой - таким образом спрайт будет перемещен ВНЕ столкновения. Это очень просто, зная правила, которые мы использовали выше для получения остатка, и зная
      как получить обратную величину битов, мы можем просто сделать это:
    x = x & ~31;
    Правильно, это ВСЕ, что требуется для выравнивания по границе 32 пикселей. Изменив 31, мы можем выровнять по любой границе - до тех пор, пока она равна степени 2. (Это эквивалентно делению на 32, затем умножению на 32, таким образом удаляя
      младшие биты).
    Если мы хотим выровнять вправо, то сделаем то же самое, но добавим 32, чтобы переместить его на следующую плитку. Все просто. Все это делает весь код столкновений монументально быстрее, и позволяет тратить процессорное время там, где оно действительно нужно.
    
  
  Ключи и двери
  
    Допустим, у вас есть уровень с несколькими дверями, и для каждой из них есть ключ. Как можно легко пометить ключ для определенной двери? Обычно вы просто присваиваете идентификатор ключу и двери. А что если вы хотите, чтобы ключ открывал 2 или 3 двери? Легко. Вы используете MASK.
      Дверь будет иметь один бит, назначенный следующим образом:
    door_id = 1; // 0001
    Остальные могут быть примерно такими:
    door_id=2; // 0010door_id=4; // 0100door_id=8; // 1000и т.д....
    Если бы мы хотели, чтобы ключ открывал двери 1 и 3, то ключ имел бы значение MASK, равное 5 (что в двоичном формате равно 101). Если мы выполним AND, и получится "не ноль", то мы знаем, что ключ может открыть
      дверь. Вы также можете иметь ключи, которые ничего не открывают, имея MASK равный 0. Смотрите код ниже для фактической проверки:
    if ((key_id & door_id) ! = 0) { opendoor(); }
    
  
  Петлевые счетчики
  
    Допустим, нам нужен простой счетчик анимации, идущий от 0 до 15 (поскольку у нас 16 кадров анимации). Обычно вы выполняете инкремент, а затем проверку if, чтобы обернуть число, но для этого примера давайте
      использовать оператор AND(&):
    счетчик = (счетчик + 1) & 15;
    Поскольку 16 - это степень 2, мы можем уменьшить это число на 1 и использовать его в качестве маски, которую затем можно использовать для обертывания значения счетчика. Если счетчик перейдет от 15 к 16, то мы получим битовый шаблон 10000, а если мы AND, что
      с 15 (битовый шаблон 01111), мы получим в итоге 00000 (просто ноль). Это означает, что приведенный выше код полезен для обертывания значений в диапазоне степени 2.
     
  
  Power Of 2 Check
  
    Что, если вы хотите проверить, является ли что-то мощностью 2? Вот небольшой трюк... Это вернет true, если заданное значение является степенью 2:
    function is_pow2(_val) { return _val & (_val - 1)) == 0; }
    Итак, если у нас есть число 51 (110011), что это даст? Ну, мы получаем вот это... 110011 & 110010, что, очевидно, оставляет нам false, так как после осталось много битов.
      после AND. Если у нас было 64 (1000000), то получается вот это... 1000000 & 0111111, что оставляет нам 0, так что это true.
    
  
  Выравнивание индекса
  
    Вот небольшой код для выравнивания по мощности 2 чисел. (1,2,4,8,16 и так далее). Это может быть очень полезно при распределении памяти или для того, чтобы убедиться, что вы записываете данные в нужные границы. В этом примере _val1 должен быть
      выровнять до _val2 байт, где _val2 - число, равное 2. Эта маленькая функция округляет UP до следующей границы нужного числа.
    function align_pow2(_val1, _val2) { return _val1 + (_val2 - 1)) & ~(_val2 - 1); }
    
    
  
   
   
   
  
    
      
        Назад: Дополнительная информация
        Следующий: Типовые таблицы
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

