
  
  Руководство по использованию буферов
  Буфер (в программировании) - это пространство в системной памяти, которое используется для хранения небольших пакетов данных практически для всего (например: передача данных, столкновения, данные о цвете и т.д.). Поскольку он хранится в системной памяти, к нему очень быстро
    и буфер обычно используется для очень краткосрочного хранения данных, например, для получения сетевой информации перед ее обработкой или для хранения контрольной точки в игре (это объясняется в примере, приведенном далее на странице).
  Буферы создаются путем выделения места в системной памяти, исчисляемого в байтах.
    которое затем резервируется для вашей игры, пока игра запущена или пока вы не удалите буфер с помощью соответствующей функции (вы можете найти все функции буфера GML, перечисленные здесь).
      Это означает, что даже когда ваша игра не находится в фокусе (например, на мобильном устройстве, когда вы принимаете звонок, игра переходит в фоновый режим), буфер будет существовать, однако если игра будет закрыта или запущена заново, буфер будет потерян.
  ПРИМЕЧАНИЕ: Перезапуск игры не очистит и не удалит буфер! Но это предотвратит дальнейший доступ к ранее созданному буферу, так как ID handle будет потерян, что вызовет утечку памяти, которая в конечном итоге приведет к краху вашей игры.
    Поэтому, перезапуская игру, не забудьте сначала удалить все буферы.
  GameMaker Studio 2 позволяет создавать четыре различных типа буферов. Причина этого заключается в том, что буферы разработаны как высоко оптимизированный временный носитель информации, и поэтому вы должны создавать буфер, соответствующий типу данных.
    иначе могут возникнуть ошибки или узкие места в коде. Прежде чем объяснять это дальше, давайте рассмотрим четыре доступных типа буферов (в GML они определены как константы ) :
   
  
    
      
        Постоянная
        описание
      
      
        buffer_fixed
         Буфер фиксированного размера в байтах. Размер задается при создании буфера и не может быть изменен повторно.
      
      
        buffer_grow
         Буфер, который будет динамически увеличиваться по мере добавления данных. Вы создаете его с начальным размером (который должен быть приблизительно равен размеру данных, которые предполагается хранить), а затем он будет расширяться, чтобы принимать данные, которые превышают
          этот начальный размер.
      
      
        buffer_wrap
         Буфер, в который будут заворачиваться данные. Когда добавляемые данные достигнут предела размера буфера, перезапись будет помещена обратно в начало буфера, и дальнейшая запись продолжится с этого момента.
      
      
        buffer_fast
         Это специальный "урезанный" буфер, который очень быстро читается и записывается. Однако он может использоваться только с типами данных buffer_u8 и должен быть выровнен по 1 байту. (Информацию о типах данных и выравнивании байтов можно найти далее на этой странице).
      
    
  
   
  Таковы типы буферов, доступные вам при использовании GameMaker Studio 2, и выбор буфера во многом зависит от того, для каких целей вы хотите его использовать. Например, буфер роста используется для хранения "моментального снимка" данных для создания
    сохранения игры, поскольку вы не знаете фактического объема данных, которые будут в него помещены, или быстрый буфер будет использоваться, когда вы знаете, что все значения, с которыми вы работаете, находятся в диапазоне от 0 до 255 или от -128 до 127, например, при обработке данных ARGB из изображения.
   ARGB данных из изображения.
  При создании буфера вы всегда должны стараться создать его такого размера, который соответствует типу, при этом общее правило заключается в том.
    что он должен быть создан для максимального размера данных, которые он должен хранить, а если есть сомнения, используйте растущий буфер для предотвращения ошибок перезаписи.
  Фактический код для создания буфера будет выглядеть примерно так:
  player_buffer = buffer_create(16384, buffer_fixed, 2);
   Это создаст фиксированный буфер размером 16384 байта с выравниванием по байтам до 2, при этом функция возвращает уникальное значение ID, которое хранится в переменной для последующего обращения к этому буферу.
  При чтении и записи данных в буфер, вы делаете это "кусками" данных, определяемыми их "типом данных". Тип данных" задает количество байт, выделяемых в буфере для записываемого значения.
    чтобы это было правильно, иначе вы получите очень странные результаты (или даже ошибки) в своем коде.
  Запись в буфер (и чтение из него) происходит последовательно, то есть одна часть данных записывается за другой, причем каждая часть данных имеет определенный тип. Это означает, что в идеале вы должны знать, какие данные вы записываете в буфер
    в любое время. Эти типы данных определяются в GML следующими константами:
   
  
    
      
        Тип данных Константа
        Байты
        Описание
      
      
        buffer_u8
        1
         Беззнаковое, 8-разрядное целое число. Это положительное значение от 0 до 255.
      
      
        buffer_s8
        1
         Подписанное 8-разрядное целое число. Это может быть положительное или отрицательное значение от -128 до 127 (0 считается положительным).
      
      
        buffer_u16
        2
         Беззнаковое 16-разрядное целое число. Это положительное значение от 0 до 65 535.
      
      
        buffer_s16
        2
         Подписанное 16-разрядное целое число. Это может быть положительное или отрицательное значение от -32,768 до 32,767 (0 считается положительным).
      
      
        buffer_f16
        2
         16-разрядное число с плавающей запятой. Это может быть положительное или отрицательное значение в диапазоне +/- 65504. (В настоящее время не поддерживается!)
      
      
        buffer_u32
        4
         Беззнаковое 32-разрядное целое число. Это положительное значение от 0 до 4 294 967 295.
      
      
        buffer_s32
        4
         Знаковое 32-разрядное целое число. Это может быть положительное или отрицательное значение от -2,147,483,648 до 2,147,483,647 (0 считается положительным).
      
      
        buffer_f32
        4
         32-разрядное число с плавающей запятой. Это может быть положительное или отрицательное значение в диапазоне +/-16777216.
      
      
        buffer_u64
        8
         64-разрядное беззнаковое целочисленное значение.(В настоящее время поддерживается не всеми функциями буфера!)
      
      
        buffer_f64
        8
         64-разрядное число с плавающей запятой.
      
      
        buffer_bool
        1
         Булево значение. Может быть только 1 или 0(true или false).
      
      
        buffer_string
        Н/Д
         Это строка UTF-8 с нулевым окончанием (0x00). По сути, в буфер сбрасывается строка GameMaker, а в конце ставится 0.
      
    
  
   
  Итак, допустим, вы создали буфер и хотите записать в него информацию, тогда вы используете что-то вроде следующего кода:
  buffer_write(buff, buffer_bool, global.Sound); buffer_write(buff, buffer_bool, global.Music); buffer_write(buff, buffer_s16, obj_Player.x); buffer_write(buff, buffer_s16, obj_Player.y); buffer_write(buff, buffer_string, global.Player_Name);
  глядя на приведенный выше пример, можно увидеть, что в буфер можно одновременно записывать данные разных типов (вы ограничены только определенным типом данных при использовании быстрого типа буфера), и эти данные будут добавляться в буфер последовательно
    (хотя их фактическое положение в буфере будет зависеть от выравнивания байтов, о чем будет сказано ниже). То же самое относится и к чтению информации из буфера, и в случае приведенного выше примера, вы будете читать из буфера в том же порядке
    что вы записали данные, проверяя при этом одинаковый тип данных, например:
  global.Sound = buffer_read(buff, buffer_bool); global.Music = buffer_read(buff, buffer_bool); obj_Player.x = buffer_read(buff, buffer_s16); obj_Player.y = buffer_read(buff, buffer_s16); global.Player_Name = buffer_read(buff, buffer_string);
  Как вы видите, вы считываете информацию в том же порядке, в котором вы считываете ее в буфер. Для получения дополнительной информации о том, как добавлять и удалять данные из буфера, смотрите примеры, приведенные ниже.
  Если вы читали эту страницу, то наверняка видели упоминания о выравнивании байтов в буфере. В основном это относится к позиции, в которой новые данные будут храниться в данном буфере. Как это работает? Ну, для одного
    буфера с выравниванием по байтам, каждая часть данных записывается в буфер последовательно, причем каждый новый фрагмент данных добавляется непосредственно после предыдущего. Однако буфер с выравниванием по 2 байтам записывает каждый фрагмент данных с интервалом в 2 байта, так что даже если
    ваша первоначальная запись составляет 1 байт данных, следующая запись будет сдвинута для выравнивания на два байта:
  Итак, если ваше выравнивание по байтам установлено, скажем, на 4 байта, и вы записываете один фрагмент данных размером в 1 байт, а затем выполняете команду tell буфера (команда tell получает текущую позицию для чтения/записи для буфера), вы получите смещение в 1 байт (смещение в данном случае
    а затем выполняете буфер tell (буфер tell получает текущую позицию для чтения/записи для буфера), вы получите смещение в 1 байт (смещение в данном случае - это количество байт от начала буфера до
    текущей позиции чтения/записи).
  Однако, если вы запишете еще один фрагмент данных размером в 1 байт, а затем выполните буферную проверку, вы получите смещение в 5 байт (даже если вы записали только 2 байта данных), так как выравнивание добавило данные, чтобы выровнять их с 4 байтами.
    выравнивание буфера.
  По сути, это означает, что выравнивание влияет только на место записи, поэтому если вы сделаете буферный запрос (buffer tell) после записи чего-либо, он вернет текущую позицию записи, которая следует сразу за данными, которые вы ранее записали.
    записали. Обратите внимание, однако, что если после этого вы запишете еще один фрагмент данных, то внутри буфера позиция записи переместится на следующую кратную величину выравнивания, прежде чем произойдет запись этого фрагмента данных.
  Ниже мы приводим несколько примеров использования буферов в проекте:
   
  Контрольная точка буфера
  
    Простым примером использования буфера в любой игре GameMaker Studio 2 для любой платформы является функция game_save_buffer().
      Эта функция делает "снимок" текущего состояния игры и сохраняет его в заранее определенном буфере, который затем может быть прочитан, чтобы снова загрузить игру в этот момент.
    ПРИМЕЧАНИЕ: Эта функция очень ограничена и предназначена для новичков, чтобы быстро запустить систему контрольных точек, но более продвинутые пользователи могут предпочесть кодировать свою собственную систему, используя функции File, из-за того, что
      игра не будет сохранять динамические ресурсы, которые вы можете создавать во время выполнения, такие как структуры данных, поверхности, добавленные спрайты и т.д....
    Первое, что нам нужно сделать, это создать новый объект для управления сохранением и загрузкой, поэтому создайте его и дайте ему событие Create. В этом событии вы можете разместить следующий код:
    SaveBuffer = buffer_create(1024, buffer_grow, 1); StateSaved = false;
    Первая строка создает растущий буфер (поскольку мы не знаем окончательного размера сохраненных данных) размером 1024 байта с выравниванием по 1 байту. Затем создается переменная для проверки, была ли игра сохранена или нет (она будет использоваться для загрузки).
    Далее мы добавим событие нажатия клавиш (например, Keypress Event ), в котором мы сохраним текущее состояние игры в созданный буфер:
    StateSaved = true; buffer_seek(SaveBuffer, buffer_seek_start, 0); game_save_buffer(SaveBuffer);
    
    Приведенные выше действия сначала установят управляющую переменную в true (чтобы она сохранилась при сохранении игры в буфер), а затем обратятся к началу буфера перед записью в него текущего состояния сохранения. Почему мы используем
      buffer_seek()? Как уже упоминалось на этой странице, чтение и запись в буфер производится с последней позиции, в которую были добавлены данные. Это означает.
      что если вы не установите буфер tell обратно в начало, то при сохранении вы будете добавлять данные в буфер в текущей позиции чтения/записи буфера. Поэтому мы используем функцию buffer_seek(), чтобы переместить tell
      в начало буфера.
    Теперь мы сохранили текущее состояние игры в буфер. Следующим шагом будет разработка кода для его загрузки, возможно, в другом событии Keypress Event:
    if StateSaved { buffer_seek(SaveBuffer, buffer_seek_start, 0); game_load_buffer(SaveBuffer); }
    Игра будет загружена в конце события, в котором вы разместите приведенный выше код.
    ПРИМЕЧАНИЕ: Это только для использования в одной комнате, а не для создания полных сохраненных игр после закрытия или перезапуска игры!
    Последнее, что нужно добавить в объект контроллера, - это код "очистки". Буферы хранятся в памяти, и поэтому, если вы не очистите их после завершения работы с ними, вы можете получить утечку памяти, которая в конечном итоге приведет к лагам и краху вашей игры.
      Поэтому вы, вероятно, добавите событие Room End Event (из категории Other event) с:
    buffer_delete(SaveBuffer);
    Теперь этот объект можно поместить в комнату и по нажатию клавиши сохранить и загрузить состояние комнаты из буфера.
     
  
  Сетевые буферы
  
    При работе с сетевыми функциями GameMaker Studio 2 необходимо использовать буферы для создания пакета данных, передаваемого по сетевому соединению. Данный пример
      призван показать, как это делается, но из-за широких возможностей сетевых функций он предназначен только для того, чтобы показать, как использовать сами буферы, а не всю сетевую систему.
    Первое, что мы покажем, это создание и использование буфера для клиентской стороны сетевого соединения. Этот буфер будет использоваться для создания небольших пакетов данных, которые затем могут быть отправлены на сервер, поэтому в событии Create для экземпляра
      мы назначим буфер следующим образом:
    send_buff = buffer_create(256, buffer_grow, 1);
    Мы делаем буфер небольшим (256 байт) - поскольку он не предназначен для хранения больших объемов данных - затем мы делаем его растущим буфером, чтобы исключить ошибки, если нам понадобится добавить больше данных для отправки в любое время, а выравнивание устанавливается на единицу для удобства.
    Теперь, допустим, мы хотим, чтобы наш клиент отправлял данные на сервер. Для этого нам нужно создать буферный "пакет", и в этом примере мы собираемся отправить событие нажатия клавиши , например, когда игрок нажимает стрелку влево, чтобы 
      для перемещения по игре. Для этого мы сначала запишем необходимые данные в буфер, а затем отправим их:
    buffer_seek(buff, buffer_seek_start, 0); buffer_write(buff, buffer_u8, 1); buffer_write(buff, buffer_s16, vk_left); buffer_write(buff, buffer_bool, true); network_send_packet(client, buff, buffer_tell(buff));
    Перед записью в буфер мы установили "tell" в начало буфера, так как networking всегда берет данные из начала буфера. Затем мы записываем контрольное значение (оно будет использовано сервером для определения типа события.
      для обработки), затем используемую клавишу, а затем состояние клавиши (в данном случае true для нажатой). Этот буфер затем отправляется сетевой функцией в виде пакета данных. Обратите внимание, что мы не отправляем весь буфер! Мы отправляем только записанные данные,
      используя функцию buffer_tell для возврата текущей позиции чтения/записи в буфере (помните, что запись в буфер перемещает "tell" в конец того, что было записано). Это делается просто для того, чтобы избежать отправки большего количества байт, чем необходимо.
    А как насчет получения данных на сервере? Полученный пакет данных должен быть записан в буфер на сервере и затем использован для обновления игры. Для этого мы будем использовать асинхронное событие Networking в объекте сетевого контроллера сервера, как показано в этом упрощенном коде ниже:
    var buff = ds_map_find_value(async_load, "buffer"); if cmd == buffer_read(buff, buffer_u8); { key = buffer_read(buff, buffer_s16); key_state = buffer_read(buff, buffer_bool); }
    Асинхронное событие будет содержать специальную временную DS карту async_load (она удаляется из памяти по окончании события автоматически), которая содержит различную информацию в зависимости от типа входящих данных из
      сети. В данном случае мы предполагаем, что карта была проверена и оказалась буферным пакетом данных, отправленным от клиента. Теперь мы проверяем первую часть данных, которая находится в буфере, чтобы узнать, какого типа событие было отправлено - в данном случае
      значение "1" представляет событие нажатия клавиши, однако при кодировании таких вещей вы должны определить константы для хранения этих значений, чтобы упростить работу - и затем сохранить нажатую клавишу и ее состояние (true = нажата,
      false = отпущена). Эта информация затем будет использоваться для обновления всех клиентов с новым статусом игрока отправляющего клиента.
    ПРИМЕЧАНИЕ: Буфер, который создается из карты DS, автоматически удаляется в конце сетевого асинхронного события, поэтому здесь нет необходимости использовать buffer_delete().
     
  
   
   
   
  
    
      
        Назад: Дополнительная информация
        Следующее: Побитовые операторы
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

