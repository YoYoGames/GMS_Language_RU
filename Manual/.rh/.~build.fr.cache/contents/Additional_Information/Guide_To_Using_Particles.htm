
  
  Руководство по использованию частиц
  Это руководство предназначено для тех, кто хочет понять, как использовать и создавать частицы. На этой странице будут рассмотрены как функцииязыка GameMaker, так и
   действияDrag and Drop™ для частиц, так что если вы никогда раньше не использовали частицы, мы надеемся, что это руководство поможет вам начать, так как они очень полезны и довольно забавны.
    очень полезны и очень увлекательны.
  Прежде чем продолжить, мы, вероятно, должны объяснить, что такое частица... По сути, частица - это графический ресурс, обладающий определенными свойствами, которые определяются системой частиц. Этими свойствами нельзя манипулировать
    непосредственно для отдельных частиц, но они изменяются коллективно через код или действия, которые используются для определения системы, к которой они принадлежат. Они очень полезны для создания красивых и ярких эффектов - или тонких и незаметных.
    - в игре без нагрузки на процессор, которую несет использование экземпляров.
  Мы уже упоминали о системах частиц, поэтому давайте объясним, что это такое, прежде чем продолжить. Думайте о системе частиц как о контейнере, который вы будете использовать для хранения частиц, готовых к использованию. Вы можете использовать код или действия для определения визуального аспекта
    частиц, а затем они помещаются в "контейнер" (систему частиц), чтобы вы могли достать его и использовать в любое время и в любом месте, где он вам понадобится.
  Прежде чем настраивать систему и создавать частицы, важно знать несколько вещей... Во-первых, большая часть кода системы частиц вызывается только один раз в игре, обычно в каком-нибудь объекте контроллера в первой
    Это не всегда так, но для простоты мы будем использовать этот сценарий для следующего краткого руководства, поскольку это самый распространенный способ использования частиц. Вы делаете это потому, что система частиц, будучи созданной, остается
    в памяти и готова к использованию в любое время, поэтому если вы создаете ее более одного раза, это может быстро увеличить использование памяти и вызвать серьезные задержки, и даже может привести к краху игры. Для простоты в этом руководстве вы создадите
   глобальную систему частиц, которая может использоваться любым экземпляром в игре в любое время.
   
  Создание системы частиц
  
    Для начала вам нужно определить систему частиц и дать ей имя, чтобы вы могли ее использовать. Поскольку это будет глобальная система, которую может использовать любой объект, вы должны сделать это в объекте контроллера или в функции инициализации, запускаемой в начале игры.
      игры. GML будет выглядеть следующим образом:
    
    global.P_System = part_system_create_layer("Instance_Layer", false);
    И использовать DnD™:
    Обратите внимание, что указанное имя слоя должно быть действительным слоем в помещении, где будет использоваться система,
      иначе частицы не будут видны. Также обратите внимание, что мы установили флаг "persistent" (как в коде, так и в DnD™) на false. Постоянная система частиц - это система, которая будет "сохраняться" в разных комнатах без необходимости уничтожать и создавать ее заново в каждой комнате.
      для каждой комнаты. Однако, чтобы упростить задачу в этом руководстве, мы не будем использовать постоянство.
    Итак, система создана, но как насчет частиц? Мы должны определить и их, иначе система бесполезна и ничего не делает.
     
  
  Определение типа частицы
  
    Чтобы использовать частицу в системе, необходимо сначала определить ее общие свойства. Они похожи на свойства объекта, но применяются только в общем случае к отдельным частицам. Это означает, что если вы зададите частицам минимальную скорость движения
      скорость 1 и максимальную скорость движения 2, любая частица, созданная системой, будет иметь случайную скорость между 1 и 2 пикселями за шаг, и в целом они будут иметь среднюю скорость 1,5. Вы должны назвать и добавить свою первую частицу в
      используя следующий GML в том же объекте, который вы использовали для создания системы:
    
    global.Particle1 = part_type_create();
    И для тех из вас, кто использует DnD™:
    Обратите внимание, что в DnD™мы также отмечаем опцию смешивания . Это включает аддитивное смешивание для частиц, о котором мы поговорим чуть ниже.
    Теперь у вас есть система и частица, которую нужно в нее поместить, но вы еще не готовы к созданию выдающихся эффектов! Вам еще предстоит определить свойства частицы, т.е. как она выглядит - ее скорость, ее вращение, ее альфа и т.д.... Есть много
      деталей, которые можно использовать для определения эффекта частицы, поэтому ниже приведен обзор наиболее важных параметров, а затем фрагмент кода и DnD™, который использует их все:
    
      форма: Форма частицы - это встроенный спрайт, который она будет использовать, по умолчанию это константа pt_shape_pixel. Существует также функция для добавления пользовательской частицы, если требуется... part_type_sprite() -
        или действие Set Particle Sprite.
      размер: Устанавливает параметры размера для типа частиц. Вы указываете минимальный начальный размер, максимальный начальный размер и увеличение размера на каждом шаге (для уменьшения размера используйте отрицательное число). Это скалярное значение, которое
        одинаково изменяет масштаб x/y базового изображения.
      color: Задает цвет для частицы, если используется один цвет. Если используются два или три цвета, это будет цветовая смесь, смешивающаяся от одного к другому в течение всего времени существования частицы.
      alpha: Устанавливает значение альфа для частицы между значениями 0 и 1. Если передано одно значение, то это будет альфа частицы, если передано два или три значения, то альфа будет смешиваться между ними в течение времени жизни частицы.
        время жизни частицы.
      speed: задает свойства скорости для типа частицы. Вы указываете минимальную и максимальную скорость, а при создании частицы выбирается случайное значение между заданными границами. Вы можете указать увеличение скорости на каждом шаге,
        и даже использовать отрицательные числа для замедления частицы (скорость никогда не станет меньше 0).
      направление: Устанавливает свойства направления для типа частицы. Вы снова задаете диапазон направлений (в градусах против часовой стрелки - 0 означает движение вправо, 90 - движение вверх и т.д.). Например, чтобы
        частица двигалась в случайном направлении, вы бы выбрали минимальное значение 0 и максимальное 360. Вы также можете указать увеличение направления для каждого шага (может быть и отрицательным).
      ориентация: Устанавливает свойства угла ориентации для типа частиц. Вы указываете минимальный угол, максимальный угол и увеличение на каждом шаге. Вы также можете указать, должен ли заданный угол быть относительным к текущему
        например: если установить все значения равными 0, а относительное значение - true, ориентация частицы будет точно следовать траектории движения частицы.
      смешивание: Устанавливает, использовать ли аддитивное смешивание или обычное смешивание для типа частиц. Этот параметр задается в функции при использовании GML и как часть инициализации частиц при использовании DnD™. Аддитивное
        означает, что частицы будут использовать режим наложения bm_add, придавая им "светящийся" вид в местах наложения, а также смешивая их со всем, что нарисовано под ними (спрайты, фоны, плитки и т.д.).
        - Очень полезно для огненных и магических эффектов (например), но лучше не использовать для таких эффектов, как дым. Поэкспериментируйте, чтобы увидеть разницу! Обратите внимание, что включение этого параметра нарушит пакетную обработку текстур при создании частиц, и поэтому потребуется больше пакетов за шаг.
        для их отрисовки - это следует учитывать, так как это может повлиять на производительность, особенно на мобильных устройствах.
      жизнь: Устанавливает границы времени жизни в шагах (игровых кадрах) для данного типа частиц. Как и в предыдущих настройках, здесь есть минимальное и максимальное значение, и частицы будут жить случайное количество шагов в пределах этих значений. Так, при времени жизни 30
        min и 30 max частица будет существовать ровно 30 шагов, а при времени жизни 20 min и 60 max частица будет существовать случайное количество шагов в диапазоне от 20 до 60.
    
    Теперь, прежде чем мы представим вам код для определения частицы, давайтенемного поговорим о " wiggle"... Хотите верьте, хотите нет, но "wiggle" - это свойство частицы и может быть установлено для многих из вышеперечисленных параметров
      индивидуально. Когда вы видите "wiggle" в качестве аргумента для функции или действия частицы, это означает, что если вы поставите число от 1 до 20, частица будет "вихлять" или колебаться между минимальным и максимальным значениями свойства,
      при этом 1 - это медленное покачивание, а 20 - очень быстрое. Таким образом, частица со скоростью минимум 2 и максимум 5 с "вихлянием" 20 будет очень быстро колебаться между минимальной и максимальной скоростями в течение времени жизни каждой созданной частицы.
    ПРИМЕЧАНИЕ: Существуют и другие незначительные свойства частиц, которые мы здесь не рассматриваем, чтобы максимально упростить процесс. Полная информация о свойствах частиц приведена на соответствующих страницах.
    Давайте теперь посмотрим на код, определяющий частицу:
    
    //Это определяет форму частиц part_type_shape(global.Particle1,pt_shape_pixel);
       //Это определяет размер part_type_size(global.Particle1,1,1,0,2);
       //Это задает ее цвет. Для этого есть три разных кода part_type_color1(global.Particle1,c_white);
       //Это ее альфа. Для этого есть три разных кода part_type_alpha1(global.Particle1,1);
       //Скорость частицы part_type_speed(global.Particle1,0.50,2,-0.10,0);
       //Направление part_type_direction(global.Particle1,0,359,0,20);
       //Изменяется вращение частицы part_type_orientation(global.Particle1,0,0,0,0,true);
       //Это режим наложения, либо аддитивный, либо нормальный part_type_blend(global.Particle1,1);
       //это время жизни в шагах part_type_life(global.Particle1,5,30);
    
    Чтобы создать такое же определение частицы в DnD™, нам понадобятся следующие действия:
    Вот и все! Теперь мы определили наши частицы, и они готовы к использованию.
     
  
  Создание частиц непосредственно в игре
  
    Существует несколько способов создания частиц, и каждый из них имеет свои плюсы и минусы. Вы можете использовать эмиттеры для создания всплеска или потока частиц, а можете создавать частицы непосредственно в точке.
      Выбор способа зависит от того, чего вы пытаетесь достичь и какой эффект хотите создать, но мы начнем с самого простого из них - создания частиц напрямую. В GML мы используем следующую функцию:
    
    part_particles_create(global.P_System, x, y, global.Particle1, 10);
    а в DnD™это было бы:
    Этот единственный код/действие выше создаст 10 частиц в заданных координатах x/y типа "Particle1"
      из нашей глобальной системы. Просто! Самое замечательное в этой строке кода/действия то, что она может быть использована в любом месте без каких-либо затруднений. Например, если вы поместите ее в глобальное событие нажатия левой кнопки мыши в объекте и измените
      x/y значения для позиции mouse_x/y, она будет создавать частицы в позиции мыши каждый раз, когда вы нажимаете кнопку. Или если у вас есть ракета, то вы можете поместить это в событие шага, и частицы дыма будут появляться каждый шаг (хотя 1 или
      2 будет лучше, чем 10!). Можно даже заставить его создавать частицы по области, например, случайным образом изменяя координаты x/y:
    
    repeat(50) { var xx = x + 20 - random(40); var yy = y + 20 - random(40); part_particles_create(global.P_System, xx, yy, global.Particle1, 1); }
    Приведенный выше код создаст 50 частиц в случайном месте в пределах квадратной области размером 40px.
      области.
    
     
  
  Создание частиц с помощью излучателей
  
    Поскольку мы уже объяснили простой способ создания частиц, давайте перейдем к более сложному способу - использованию эмиттеров . Эмиттеры - это еще одна часть системы частиц, которая должна быть определена перед использованием, поэтому мы создадим
      создадим глобальный эмиттер так же, как мы это делали для системы и частиц. Нам также нужно решить, будет ли эмиттер статичным (недвижущимся) или нет, и будем ли мы выпускать частицы взрывом или потоком .
      а также решить, на какой площади и какое распределение будет использовать эмиттер.
    Что все это значит? Ну, статический эмиттер - это тот, который вы можете определить один раз и забыть о нем, поскольку он не будет никуда двигаться в течение всей игры, т.е. представьте себе костер из поленьев - он не движется, он просто испускает пламя и
      поэтому он статичен, но для огненного шара потребуется динамический эмиттер, и он будет перемещаться по экрану. Что касается всплеска или потока, то всплеск - это одноразовый взрыв частиц, в то время как поток - это постоянный поток частиц.
      на каждом шагу. Что касается области и распределения, то с помощью эмиттеров можно определить область для излучения частиц (это может быть прямоугольник, эллипс, ромб или линия), а также кривую распределения (гауссову, обратную гауссову или линейную).
    Следующие изображения иллюстрируют различные типы формы области, доступные для излучателей:
     
     
     
     Здесь показаны кривые распределения (линейная, гауссова и обратная гауссова):
    
    Ниже приведен пример кода/действий, необходимых для определения двух эмиттеров, которые обычно идут в событии Create объекта контроллера, сразу после определения системы частиц. Один из них будет статичным и будет распылять частицы по
      площадь всей комнаты, а другой будет динамическим и будет следовать за мышью и вырываться каждые 30 шагов из небольшого эллипса:
     
    global.Particle1_Emitter1 = part_emitter_create(global.P_System); global.Particle1_Emitter2 = part_emitter_create(global.P_System);
       //Установите область, которая будет излучать частицы part_emitter_region(global.P_System, global.Particle1_Emitter1, 0, room_width, 0, room_height, ps_shape_rectangle, ps_distr_linear); part_emitter_region(global.P_System, global.Particle1_Emitter2,
      mouse_x-10, mouse_x+10, mouse_y-10, mouse_y+10, ps_shape_ellipse, ps_distr_gaussian);
       //Установите первый поток на 10 частиц каждый шаг part_emitter_stream(global.P_System, global.Particle1_Emitter1, global.Particle1, 10);
       //Теперь об этом можно забыть, так как он будет работать, пока ему не прикажут остановиться... //Установите событие alarm[0] для разрыва частиц эмиттера2... alarm[0] = 30;
    Итак, здесь мы создаем два излучателя частиц, которые назначаются системе частиц, созданной нами
      в самом начале. Функции/действия для создания этих излучателей позволяют нам определить область в комнате, над которой они будут испускать частицы, а также указать тип испускаемых частиц, форму и распределение в пределах определенной области. Функции/действия
      функции/действия возвращают числовое значение, которое является идентификатором излучателя, и мы сохраняем его в переменной, чтобы использовать дальнейшие функции излучателей для нацеливания на эти излучатели.
    Теперь у нас есть код/DnD™ для потока частиц (эти частицы будут испускаться каждый шаг игры без нашего участия), но мы также хотим добавить событиеAlarm[0], чтобы частицы взрывались через определенные промежутки времени.
      интервалы времени:
    
    part_emitter_region(global.P_System, global.Particle1_Emitter2, mouse_x - 10, mouse_x + 10, mouse_y - 10, mouse_y + 10, ps_shape_ellipse, ps_distr_gaussian); part_emitter_burst(global.P_System, global.Particle1_Emitter2, global.Particle1, 30); alarm[0] = 30;
    Всплеск частиц - это просто однократный взрыв частиц из излучателя, а не постоянный
      поток их на каждом игровом шаге.
    Но что если вы хотите, чтобы несколько объектов испускали частицы? Глобальный излучатель может одновременно находиться только в одном месте, поэтому вам нужно будет создать локальные излучатели в каждом объекте. Эти излучатели будут по-прежнему использовать глобальную систему частиц и любые частицы.
      но они могут быть разных форм и размеров и перемещаться вместе с объектом, что делает их идеальными для ракет, пуль и прочего. Код, который вы будете использовать, точно такой же, как и выше, но без префикса "global" перед
      перед именами эмиттеров.
    С созданием частиц разобрались, но есть еще одна вещь, которая очень важна... Очистка, когда вы закончите с ними.
     
  
  Уборка
  
    Как уже упоминалось в начале, после создания система частиц (и ее частицы, эмиттеры и т.д.) сохраняется в памяти для мгновенного использования. Отлично, но что произойдет, если вы перезапустите игру? Или если ваш игрок умрет и начнет комнату заново? Ну, если вы
      не справитесь с управлением игрой, вы получите утечку памяти. Это когда что-то было создано, использовало память, но было "отнесено", то есть GameMaker больше не имеет к нему доступа. Такая вещь будет
      медленно съедает память и вызывает задержку в игре или даже блокирует компьютер, что приводит к краху игры, и это довольно распространенная проблема среди начинающих пользователей систем с частицами.
    Как этого избежать? В GameMaker Studio 2 есть GML и DnD™для удаления систем частиц, их излучателей и частиц из памяти, когда они не используются, и при небольшом планировании при использовании следующего кода/действий вы можете легко предотвратить
      эту потенциальную проблему.
    Прежде всего, вам нужно решить, где вы собираетесь создать систему и как вы будете ее использовать. Вы можете создать глобальную систему в событии начала игры объекта, который находится в вашей первой комнате (например, меню или титульный экран),
      но это означает, что если вы перезапустите игру, используя game_restart() функцию, она будет создана заново и вызовет утечку памяти. Или вы
      можно создать локальную систему в экземпляре в любой комнате, но опять же, если вы покинете комнату, система будет недоступна и вызовет утечку памяти. Чтобы избежать этого, вам нужно иметь что-то вроде этого в параметре Мероприятие по окончанию игры      или Событие очистки вашего объекта:
    part_type_destroy(global.Particle1); part_emitter_destroy(global.P_System, global.Particle1_Emitter); part_emitter_destroy(global.P_System, global.Particle2_Emitter); part_system_destroy(global.P_System);
    
    Это удалит определенные частицы, излучатели, а затем систему из памяти, чтобы вы могли перезапустить
      игру или сменить комнату. Помните, что после того, как вы подумали, где будет наиболее подходящее место для создания системы, подумайте и о том, где будет наиболее подходящее место для ее уничтожения!
     
  
   
  Теперь вы знаете основы о частицах, системах частиц и эмиттерах, так что теперь вы можете добавить их в свою игру! Но прежде чем бросаться добавлять эффекты частиц во все подряд, обратите внимание, что хотя частицы менее требовательны к процессору, чем инстансы, они
    не являются решением всех проблем, поскольку они будут вызывать задержку, если у вас их тысячи одновременно. Лучше всего экспериментировать и использовать их осторожно, чтобы визуально "оживить" игру и придать ей больше привлекательности, не переусердствуя при этом.
    это.
   
   
  Выпадающее название
  
    Введите здесь текст выпадающего списка
  
   
   
  
    
      
        Назад: Дополнительная информация
        Следующее: Руководство по использованию шейдеров
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

