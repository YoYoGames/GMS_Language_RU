
  
  Лучшие практики при программировании
  На этой странице мы расскажем о некоторых "лучших практиках" при программировании игры, а также немного о внутреннем устройстве GameMaker Studio 2. Однако прежде чем продолжить, стоит отметить два очень важных момента.
    момента:
  
    Это руководство, а не все-все-все-определяющий-100%-совершенный метод написания вашей игры! Упомянутые здесь вещи, как правило, больше относятся к организационной и микро-оптимизации и должны быть включены в ваши навыки программирования, когда вы почувствуете себя комфортно в GML.
      когда вы почувствуете себя комфортно с GML и решите, что они уместны.
    Если ваша игра работает нормально и вас все устраивает, не спешите все менять только для того, чтобы выжать несколько дополнительных FPS. Вы должны найти баланс между читабельным, гибким и модульным кодом и временем и энергией.
      необходимыми для внесения изменений, а также общим выигрышем в конечном итоге. В общем, если ничего не сломалось, не чините, а то, что вы узнали здесь, сохраните для следующего проекта.
  
  Сказав это, давайте продолжим и рассмотрим некоторые общие советы по написанию хорошего GML-кода, которые вы можете применять в любое время...
  
  Стиль программирования
  
    Когда дело доходит до написания кода, у каждого есть свой стиль. Стиль, в котором вы программируете, - это то, как вы расставляете скобки, как отступаете от строк, как объявляете и называете переменные и т.д., и это очень важно для того, чтобы ваш код был понятен и читаем
      для других людей (и для вашего будущего "я", когда вам придется вернуться к этому проекту после некоторого времени работы над чем-то другим).
    Существует много, много стилей программирования, и некоторые могут утверждать, что их стиль является лучшим для использования, но правда в том, что практически любой стиль подходит, если вы последовательны при
      если вы последовательны в его использовании и ясно и очевидно , что все является и делает.
    Приведенное выше изображение является примером объявления функции в сценарии для иллюстрации вышеизложенных моментов. Вы
      видите, что в нем используются комментарии в стиле JSDoc, чтобы четко объяснить, что все это делает, а стиль кодирования соответствует, с отступами в 4 пробела, подчеркиваниями, используемыми для локальных переменных, протоколируемым выводом и т.д...
    Также обратите внимание, что хотя редактор скриптов позволяет сворачивать код в каждой из открытых/закрытых скобок, вы можете использовать теги #region и #endregion для разделения частей вашего кода и значительного улучшения читабельности.
      особенно при работе с большими скриптами, содержащими множество функций. Регионы также можно комментировать - см. раздел "Редактирование" на этой странице руководства):
    При написании кода следует помнить, что при компиляции готовой игры GameMaker Studio 2 удаляет комментарии, убирает ненужные переносы строк, подставляет константные/простые/энумные значения и вообще сжимает код.
      комментарии, удаляет ненужные разрывы строк и пробелы, подставляет постоянные/макро/энум значения и вообще сжимает ваш код. Это означает, что вы можете добавлять столько пробелов вокруг вашего кода, сколько необходимо, и
      вам не нужно беспокоиться о том, чтобы комментарии были короткими или использовались редко.
     
  
  Используйте локальные переменные
  
    Продолжая тему стиля программирования, можно сказать, что многие начинающие программисты стремятся впихнуть как можно больше в одну строку кода. Например:
    draw_sprite(sprite_index, image_index, x + lengthdir_x(100, point_direction(x, y, mouse_x, mouse_y)), y + lengthdir_y(100, point_direction(x, y, mouse_x, mouse_y));
    Хотя он и не совсем нечитабелен, но неэффективен (например, функция point_direction() вызывается дважды), а также грязен и неудобен на вид. Гораздо лучше было бы выразить это как:
    var p_dir = point_direction(x, y, mouse_x, mouse_y); var local_x = x + lengthdir_x(100, p_dir); var local_y = y + lengthdir_y(100, p_dir); draw_sprite(sprite_index, image_index, local_x, local_y);
    Память и ресурсы, необходимые для создания этих локальных переменных, ничтожно малы, и их значительно перевешивает мгновенная польза, которую вы (или любой другой человек, читающий код позже) получите от его ясности. Та же идея должна быть применена и к функциям, где
      следует присваивать разумные имена входным переменным, использовать четкое форматирование и локальные переменные там, где это необходимо, чтобы сделать код максимально читабельным.
    Локальные переменные быстро обрабатываются в игре, поэтому используйте их по максимуму, а если выражение появляется в блоке кода или скрипте два или более раз, подумайте о создании локальной переменной для него. При использовании целей YoYo Compiler (YYC), если вы ссылаетесь на global или переменные экземпляра несколько раз в функции или блоке кода, особенно полезно присвоить их локальной переменной в начале кода.
      и затем ссылаться на эту локальную переменную, так как это обеспечит гораздо лучшую производительность.
     
  
  Массивы
  
    Массивы быстры в использовании и требуют меньше памяти, чем структуры данных, но их можно еще больше оптимизировать. Когда вы создаете массив, память для него выделяется в зависимости от его размера, поэтому вы
      старайтесь сначала инициализировать массив до его максимального размера, даже если вы не планируете заполнять его в дальнейшем. Например, если вы знаете, что массив должен содержать максимум 100 значений, вы сразу инициализируете его до 100 слотов,
      используя array_create() функция:
    array = array_create(100, 0);
    Это выделяет память для него одним "куском", при этом все значения массива устанавливаются в значение 0 по умолчанию, и помогает поддерживать быструю работу, поскольку в противном случае каждый раз, когда вы добавляете новое значение в массив, вся память должна быть выделена заново.
    ПРИМЕЧАНИЕ: Для цели HTML5 присвоение массивов подобным образом не применяется, и ваши массивы должны инициализироваться с 0 для этой цели! Вы можете легко справиться с этим, проверив переменную os_browser, например:
    if (os_browser == browser_not_a_browser)
    {
    array_create(100, 0);
    }
else
    {
    for (var i = 0; i < 100; ++i;)
        {
        array[i] = 0;
        }
    }
    Вы также можете освободить память, связанную с массивом, установив используемую переменную равной 0. Таким образом, чтобы очистить массив из приведенного выше примера кода, достаточно использовать:
    массив = 0;
    Также обратите внимание, что массивы передаются по ссылке, но при изменении будут копироваться целиком (такое поведение называется copy on write). Таким образом, если вы передаете массив в функцию, вы передаете ссылку на
      исходный массив, и любые значения, считанные из него, будут получены из исходного источника. Это хорошо и быстро, но если вам нужно изменить какие-либо значения массива, сам массив дублируется в момент записи, и все сделанные изменения должны быть возвращены из функции, иначе они будут потеряны.
      Это намного медленнее и потребляет больше памяти, поэтому будьте осторожны при использовании массивов в функциях.
    Однако вы можете избежать такого поведения при копировании при записи, используя специальный аксессор массива @, так как он дает прямой доступ к базовому массиву. Например:
    // Вызываем функцию, передавая наш массив my_function(my_array);
    
    // Функция выглядит следующим образом:
       function my_function(_a) {
       // Массив будет скопирован и копия модифицирована, // что потребует от вас использования "return _a", позже _a[0] = 100; // Это изменит ОРИГИНАЛЬНЫЙ массив напрямую и // не требует его возврата _a[@0]
      = 100; }
    
     
  
  Структуры данных
  
     Структуры данных в GameMaker Studio 2 были оптимизированы и стали намного быстрее, чем в предыдущих версиях GameMaker. Их по-прежнему необходимо очищать (уничтожать), когда
      для освобождения памяти, и они все еще могут быть медленнее, чем, скажем, массивы, но простота использования и дополнительные функции для работы с данными, которые они содержат, часто перевешивают минимальную разницу в скорости, так что не бойтесь использовать их в ваших
      играх.
    
    Следует отметить, что из всех структур данных, DS Maps, в частности, отличаются высокой скоростью чтения и записи, что делает их отличным вариантом для всех типов задач.
    Ранее мы упоминали аксессоры для массивов, но они также доступны для структур данных, что может помочь очистить ваш код и сделать его намного легче для чтения.
     
  
  Столкновения
  
    В GameMaker Studio 2 существует множество способов борьбы с коллизиями, и большинство из них сопровождается небольшими дополнительными нагрузками на процессор. Функции collision_ и point_, place_ и instance_ - все они основаны на проверке ограничивающих ра мок у
      все экземпляры данного типа в комнате, и хотя в движок встроена некоторая оптимизация для ограничения этих проверок, столкновения никогда не являются наиболее эффективными. Если вы начнете использовать точные коллизии, производительность
      также заметно ухудшится, поскольку вы будете не только проверять граничные рамки, но и выполнять проверку на пиксель, что очень медленно. В техническом блоге YoYo Games это обсуждается здесь:
    
      Опасности точного обнаружения столкновений
    
    Это не означает, что вы не должны использовать эти функции, так как они могут быть очень удобными. Однако вы должны знать, какие из них использовать и когда, поскольку все они работают немного по-разному и имеют разную скорость. Примерное правило заключается в том, что
      функции place_ работают быстрее, чем функции instance_, которые работают быстрее, чем функции collision_ и point_, поэтому читайте страницы
      в руководстве по каждому из этих типов функций и убедитесь, что выбрали наиболее подходящую для каждой ситуации.
    В качестве альтернативы рассмотрите возможность создания системы столкновений на основе плитки, которая может быть создана с помощью функций tilemap или даже
      пользовательского двумерного массива или сетки DS. Они будут очень быстрыми и помогут увеличить скорость вашей игры. Однако если вы используете нерегулярную местность или стены и объекты, которые не выравниваются по сетке, они могут не подойти. Вы можете найти очень простой
      учебник по столкновениям тайлмапов по следующей видеоссылке
    
      Коллизии плиток в GameMaker Studio 2
    
     
  
  Замена текстур и партии вершин
  
    Если вы включите наложение отладки, вы увидите, что при тестировании в верхней части экрана отображаются две цифры в скобках. Первая - это количество
      выполняемых подмен текстур , а вторая - количество вершинных батчей. На эти цифры влияет множество факторов, и вам никогда не удастся свести их к (0) (0), поскольку движок требует выполнения одного или двух операций на каждом шаге.
      каждый шаг, но вы должны стремиться снизить эти значения как можно ниже.
    Для замены текстур лучшим и наиболее эффективным способом является оптимизация того, как ваши спрайты и фоны
      хранятся на странице текстур. Это делается в свойствах спрайта, и вы можете создавать страницы текстур в редакторе групп текстур. Если у вас есть несколько
      изображений, которые используются только в главном меню (например), то поместите их вместе на отдельную страницу текстур. То же самое, если у вас есть изображения, специфичные для уровня, или для игрока и врагов,
      и т.д. В общем, вы хотите сгруппировать их по использованию, чтобы максимально сократить количество подмен. Кроме того, для оптимизации VRAM вы можете использовать различные функции prefetch и flush для загрузки и удаления текстур из памяти по мере необходимости.
    ПРИМЕЧАНИЕ: Как уже упоминалось в начале этой страницы, если ваша игра работает нормально с приличным FPS, то не стоит слишком беспокоиться о замене текстур... особенно при создании проектов на настольных мишенях. Эти оптимизации лучше всего подходят для
      при использовании в больших играх или на мобильных устройствах низкого класса, а при неправильном использовании они могут негативно повлиять на производительность.
    Информация о вершинах отправляется "партиями" на GPU для отрисовки, и в целом, чем больше партия, тем лучше. Поэтому при отрисовке следует избегать "разбиения" партии, так как это увеличит количество партий вершин, отправляемых в графический процессор.
      GPU. Существует ряд вещей, которые могут нарушить пакет, основными из них являются режимы наложения, установка цвета рисования, установка альфа-канала рисования и рисование с использованием встроенных форм и
      примитивы.
    
    Так, если у вас есть несколько экземпляров пули, которые рисуют, используя режим наложения bm_add, например, вы будете создавать новую партию вершин для каждой из них, что определенно плохо! Вместо этого у вас есть объект контроллера
      в вашей игре, который рисует все пули вместо этого, например, так:
    gpu_set_blendmode(bm_add); with (obj_BULLET) { draw_self(); }  gpu_set_blendmode(bm_normal);
    
    ПРИМЕЧАНИЕ: Это относится не только к использованию bm_add - любое изменение смешивания нарушит пакет и приведет к снижению производительности.
    Таким образом, все пули будут нарисованы в одной партии. Этот метод может быть применен также к альфа и цвету рисования, и на самом деле разумное использование функций gpu_set_blendenable(),
      gpu_set_alphatestref(), и gpu_set_alphatestenable() может
      значительно повысить производительность и могут быть включены/выключены по мере необходимости в коде вашего проекта, хотя они могут не подходить для всех типов графики или проектов.
    ПРИМЕЧАНИЕ: Если вам не требуется, чтобы экземпляр рисовал сам себя при использовании контроллера таким образом, вы можете просто добавить комментарий в событие Draw Event, чтобы подавить рисование по умолчанию, или сделать экземпляр невидимым (хотя это приведет к тому.
      хотя это предотвратит выполнение кода для экземпляра во всех событиях рисования).
    Другой способ уменьшить эти числа - отключить опцию Separate Texture Page для спрайтов, если это не является абсолютно необходимым. Каждое изображение, сохраненное таким образом, отправляется на свою собственную страницу текстур и по-разному сортируется, поэтому лучше иметь эти изображения
      на обычной текстурной странице лучше. Затем вы можете получить UVS-координаты с помощью функции sprite_get_uvs() функция
      и сохранить их в переменных для последующего использования. Это может быть небольшое количество дополнительного кода, но эффект, который вы получите, того стоит. Обратите внимание, что этот метод не позволяет повторять текстуры!
    Как и в случае со всеми этими советами, если их изменение усложняет вашу жизнь, а игра работает нормально, не стоит слишком беспокоиться об этом...
     
  
  Частицы
  
    Частицы предлагают очень быстрый и эффективный способ создания динамических эффектов в вашей игре, и в целом они обеспечивают хорошую производительность. Однако стоит отметить, что
      использование аддитивного смешивания, альфа-смешивания и смешивания цвета для частиц может снизить эту производительность, особенно на мобильных устройствах, поэтому если вам это не нужно, не используйте это! Аддитивное смешивание, в частности, может значительно увеличить вершинные
      и должны использоваться с осторожностью.
    Обратите внимание, что для HTML5, не поддерживающего WebGL, наличие разноцветных исчезающих частиц потребует большого количества кэширования изображений и будет очень медленным. Однако, поскольку спрайты частиц могут быть анимированными, вы можете создать анимированный спрайт, имеющий подизображения, которые
      меняют цвет, а затем использовать его для частицы. Это все равно будет выглядеть как постепенное изменение цвета, но не потребует постоянного создания кэш-изображений.
    Вы можете узнать больше о частицах на странице Руководство по использованию частиц.
     
  
  Поверхности
  
    Наконец, мы вкратце коснемся использования поверхностей, поскольку GameMaker Studio 2 имеет довольно значительную оптимизацию при их использовании в ваших играх: возможность
      включать и выключать буфер глубины.
    Когда вы просто используете поверхности, как обычно, GMS2 фактически создает поверхность и сопутствующий буфер глубины для обеспечения правильной сортировки глубины при рисовании чего-либо в 3D. Однако, для большинства 2D игр этот дополнительный буфер глубины просто не нужен и поэтому
      занимает дополнительное пространство памяти и время обработки, которое можно было бы использовать для других целей. Именно здесь и появляется функция surface_depth_disable() 
      в игру...
    Эту функцию можно вызвать перед созданием поверхности, чтобы отключить генерацию буфера глубины, и все поверхности, созданные после этого, не будут иметь созданного для них буфера глубины. Вы можете включать/выключать эту функцию по мере необходимости, и даже можете вызвать ее один раз в начале игры, чтобы отключить буфер глубины для всех поверхностей, созданных после этого.
      ее один раз в начале игры, чтобы отключить буферы глубины для всех последующих вызовов поверхностей (и в большинстве 2D-игр это нормально). Это не даст значительного прироста производительности, но это определенно то, что следует иметь в виду, если ваша игра в значительной степени полагается на
      и может остановить нехватку памяти на устройствах с низким уровнем производительности.
  
   
  Помимо основных вещей, упомянутых выше, есть и другие, более общие вещи, которые могут помочь в производительности и которые также считаются "хорошей практикой":
  
    не бойтесь использовать тригонометрические функции, поскольку (вопреки распространенному мнению) они довольно быстрые, особенно по сравнению с частицами, столкновениями, струнами и т.д....
    не помещайте в события Draw код, не предназначенный для рисования предметов
    использовать сигнал тревоги для вызова любого кода, который не нужно вызывать каждый шаг (вместо того, чтобы просто добавить это в событие Step)
  
  Но, как мы уже упоминали в начале страницы, все эти оптимизации необязательны, и если ваша игра прекрасно работает с 60 вершинными партиями, 80 сменами текстур, аддитивным блендингом и т.д., то не стоит слишком беспокоиться об этом! Просто помните об этих вещах
    при программировании вашей следующей игры...
   
   
   
  
    
      
        Назад: Дополнительная информация
        Следующее: Файловая система
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

