
  
  Руководство по использованию шейдеров
  Шейдеры часто используются для создания красивых графических эффектов в играх. Они также являются одними из самых продвинутых функций GameMaker Studio 2, поэтому необходимо иметь базовое понимание программирования и работы GameMaker Studio 2.
    прежде чем приступать к работе с ними.
  Итак, что же такое шейдер? Изначально они создавались для создания теней для освещения (отсюда и название), но сейчас они используются для создания огромного количества разнообразных эффектов. Код шейдера похож на обычный код, но он (почти всегда) выполняется графическим процессором, а не
    центральным процессором. Это отличие имеет свой набор правил и ограничений, но мы рассмотрим их позже.
  Каждый шейдер состоит из двух отдельных компонентов: вершинного шейдера и фрагментного шейдера (также называемого пиксельным шейдером). Начнем с вершинного шейдера. Каждый спрайт формируется прямоугольником,
    но компьютеры любят рисовать треугольники, поэтому прямоугольники делятся на два треугольника (иногда их называют квадратами). В результате у нас остается шесть вершин (углов) на спрайт, но две из них одинаковые, поэтому нам следует беспокоиться только о четырех.
    Теперь представьте, что у нас есть цикл for, который перебирает все вершины и выполняет код вершинного шейдера для каждой из них. Это позволяет нам изменять положение и цвет вершины перед передачей ее в шейдер фрагмента, поскольку шейдер вершины выполняется
    раньше.
  Вот как это будет выглядеть:
  Для фрагментного шейдера можно представить тот же цикл, что и раньше, но на этот раз он просматривает каждый отдельный пиксель в вашем
    спрайта, предоставляя вам такую информацию, как местоположение и цвет этого пикселя. В коде фрагментного шейдера вы выполняете операции и вычисления для определения цвета этого пикселя, чтобы получить нужный эффект. Например, если вы хотите, чтобы шейдер сделал
    ваш спрайт черно-белым, то вы вычислите, какого оттенка серого должен быть каждый пиксель, чтобы создать эффект.
  Это будет выглядеть примерно так:
  Причина, по которой код шейдеров обычно выполняется графическим процессором, заключается в том, что он более эффективен в этом. Современные центральные процессоры обычно имеют
    от двух до восьми ядер. Каждое ядро может выполнять одну задачу за раз, поэтому, используя преимущества нескольких ядер, мы можем выполнять множество задач одновременно. В отличие от них, современные графические процессоры могут выполнять тысячи и даже десятки тысяч задач одновременно.
    одновременно. Это полезно для шейдеров, поскольку мы можем одновременно выполнять код шейдера для тысяч пикселей. Ограничение заключается в том, что мы имеем доступ только к начальному состоянию спрайта, поэтому мы не знаем о любых модификациях, сделанных
    в других пикселях, поскольку мы не можем быть уверены, что код уже выполнялся на них.
  ПРИМЕЧАНИЕ: GameMaker Studio 2 позволяет пользователям писать шейдеры на языках GLSL (OpenGL Shader Language), HLSL (High-level Shader Language, используется при работе с DirectX) и GLSL ES (подмножество GLSL, распространенное в мобильных устройствах).
    GLSL, распространенное в мобильных устройствах). Здесь мы используем GLSL ES в качестве языка шейдеров, поскольку именно он обеспечивает наилучшую совместимость с целевыми платформами. Как правило, именно его вы всегда хотите использовать, если только у вас нет
    если только у вас нет очень специфических потребностей и вы не понимаете ограничения других шейдерных языков. Математика и методы должны быть схожими для всех трех языков, за исключением некоторых различий в синтаксисе.
  Вершинный шейдер выполняется первым, и, как мы объясняли выше, он работает с вершинами. Он используется для вычисления позиций, нормалей и координат текстуры. Эти шейдеры не особенно полезны в 2D, так как каждый спрайт обычно является
    квадрат, но они могут быть использованы для некоторого перекоса, масштабирования и т.д.. Они становятся гораздо более полезными в 3D для расчетов освещения и деформации сетки. Фрагментные шейдеры гораздо интереснее, и именно они будут рассматриваться здесь, поскольку фрагментный шейдер - это то место, где мы получаем информацию о фрагменте.
   шейдер - это место, где мы получаем информацию о наших текстурах и можем настраивать конечный цвет каждого пикселя в нашем изображении.
   
  Переменныешейдера 
  Если вы создавали шейдер в GameMaker Studio 2, вы могли заметить следующие ключевые слова в стандартном проходном шейдере. Эти ключевые слова помогают шейдеру понять назначение и область применения каждой переменной:
  
    Атрибут: Это переменные, передаваемые OpenGL вершинному шейдеру. Они могут изменяться для каждой вершины и доступны только для чтения. Они включают такую информацию, как положение вершины, координаты текстуры, цвет вершины и ее
      нормаль.
    Переменные: Это переменные, используемые для передачи данных между вершинным и фрагментным шейдерами. Они доступны для записи в вершинном шейдере, но доступны только для чтения во фрагментном шейдере.
    Унифицированные: Это переменные, которые изменяются для каждого объекта и передаются шейдеру пользователем. Они могут использоваться как в вершинных, так и во фрагментных шейдерах, но доступны только для чтения.
  
  Вы также увидите использование vec в качестве ключевого слова. Оно используется для идентификации векторной переменной в шейдере, и вскоре вы увидите, что векторы очень важны при работе с шейдерами . Именно поэтому они реализованы как базовый
    типа в GLSL. Если вы не знакомы с ними, то это математический термин, представленный в виде матрицы с одним столбцом. В программировании мы обычно представляем их в виде массива, где количество компонентов соответствует размерности. Двухмерные и трехмерные
    векторы часто используются для позиций, координат текстур или цветов без альфа-канала, в то время как четырехмерные векторы используются для цветов с альфа-каналом. Мы также можем указать, какие значения они содержат: булевы, целые числа или значения с плавающей запятой. Синтаксис
    синтаксис для объявления вектора следующий:
  vec2 firstVec; // Двумерный вектор плавающих чисел vec3 secondVec; // Трехмерный вектор плавающих чисел vec4 thirdVec; // Четырехмерный вектор плавающих чисел
     bvec3 boolVec; // Трехмерный вектор булевых чисел ivec4 intVec; // Четырехмерный вектор булевых чисел
  Чтобы инициализировать их, мы можем использовать конструктор для создания вектора. Вам нужно предоставить столько же значений, сколько длина вектора, но вы можете смешивать и сопоставлять скаляры и меньшие векторы, чтобы достичь заданной длины. Вот несколько примеров
    этого:
  // Простой 2D вектор с 2 скалярными значениями vec2 firstVec = vec2(2.0, 1.0); // Четырехмерный вектор с использованием 2 скаляров и vec2 для создания 4 значений vec4 secondVec = vec4(1.0, firstVec, 0.0); // Трехмерный вектор с использованием 1 компонента vec4 плюс a
    vec2 для создания 3 значений vec3 thirdVec = vec3(secondVec.x, firstVec);
  Мы также можем присвоить им другой вектор той же длины (или изменить вектор до нужной длины, но об этом мы расскажем чуть позже):
  vec3 firstVec; vec3 secondVec = firstVec; vec4 thirdVec = secondVec.xyz; vec2 fourthVec = thirdVec.zx;
  При обращении к компонентам вектора в GLSL у нас есть несколько вариантов. Самый простой - рассматривать вектор как массив и обращаться к компонентам с помощью квадратных скобок, например, так:
  vec4 myVec; myVec[0] = 1.0; myVec[1] = 0.0; myVec[2] = 2.0; myVec[3] = 1.0;
  Однако существует и другой способ доступа к компонентам со следующим синтаксисом:
  vec4 myVec; myVec.x = 1.0; myVec.y = 2.0;
  Для доступа к ним используются имена компонентов внутри вектора. Вы можете использовать x, y, z или w, чтобы получить первый, второй, третий или четвертый компонент соответственно. Мы называем этот метод swizzling , потому что следующий синтаксис также
    действителен:
  vec4 firstVec; vec3 secondVec = firstVec.xyz; vec2 thirdVec = secondVec.zy; vec4 fourthVec = thirdVec.yxxy;
  Как видите, мы можем использовать любую комбинацию до четырех букв для создания вектора такой длины. Мы не можем попытаться получить доступ к компоненту, который будет выходить за рамки (например, попытаться получить доступ к w в secondVec или
   thirdVec, так как у них нет четвертого компонента). Кроме того, мы можем повторять буквы и использовать их в любом порядке, если векторная переменная, которой она присваивается, имеет тот же размер, что и количество используемых букв.
  По очевидным причинам, при использовании swizzle для установки значений компонентов, вы не можете использовать один и тот же компонент дважды. Например, приведенный ниже вариант не подходит, так как вы пытаетесь установить один и тот же компонент на два разных значения:
  myVec.xx = vec2(2.0, 3.0);
  И последнее, мы использовали xyzw в качестве маски, что обычно происходит при работе с позициями. Есть еще два набора масок, которые вы можете использовать: rgba (используется для цветов) или stpq (используется для координат текстуры). Внутренне между этими масками нет никакой разницы, и мы используем их только для того, чтобы сделать код более понятным, что представляет собой вектор в данном случае. Кроме того, мы не можем комбинировать маски swizzle в одной операции, поэтому
    это недействительно:
  myVec = otherVec.ybp;
  Это было много определений и информации, но знание этих вещей необходимо для понимания самих шейдеров.
   
  Создание шейдера
  Когда вы создаете шейдер в GameMaker Studio 2, он открывает для вас два файла: вершинный шейдер (.vsh) и фрагментный шейдер (.fsh). Это самый простой шейдер, который вы можете создать, который берет спрайт,
    считывает текстуру и окрашивает каждый пиксель в этот цвет. Если вы укажете цвета вершин при рисовании, эти цвета будут смешиваться с текстурой.
  Давайте пройдемся по коду только что созданного шейдерного актива и проанализируем его, начиная с вершинного шейдера.
  // Passthrough Vertex Shader атрибут vec3 in_Position; // (x,y,z) // атрибут vec3 in_Normal; // (x,y,z) не используется в этом шейдере. атрибут vec4 in_Colour; // (r,g,b,a) атрибут
    vec2 in_TextureCoord; // (u,v)
     изменяющийся vec2 v_vTexcoord; изменяющийся vec4 v_vColour;
     void main() {
     vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0); gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;      v_vColour = in_Colour; v_vTexcoord = in_TextureCoord; }
  
  За пределами главной функции мы видим объявления некоторых переменных и их классификаторы. Атрибуты даны нам GameMaker. Переменные создаются пользователем, чтобы передать информацию шейдеру фрагмента. Внутри главной функции
    производятся вычисления для определения экранной позиции вершины:
  
    Сначала мы создаем vec4 и инициализируем его компонентами позиции, добавляя единицу в качестве четвертого компонента. В линейной алгебре принято, что мы добавляем единицу к четвертой компоненте, если вектор представляет
      точку, или ноль, если вектор представляет реальный вектор.
    Далее нам нужно добавить этот четвертый компонент, чтобы умножить его на матрицу MATRIX_WORLD_VIEW_PROJECTION, которая представляет собой матрицу 4x4. Это умножение спроецирует мировую позицию вершины на экранные координаты.
    Наконец, мы передаем цвет вершины и координаты текстуры в шейдер фрагмента через наши изменяемые переменные.
  
  Этот шейдер следует оставить в покое, если вы не планируете играть с позициями вершин, и он не будет использоваться ни в одном из примеров, приведенных ниже, потому что все показанные эффекты будут созданы с помощью шейдера фрагмента.
  Давайте теперь быстро посмотрим на шейдер фрагмента:
  // Passthrough Fragment Shader изменяющийся vec2 v_vTexcoord; изменяющийся vec4 v_vColour;
     void main() {
     gl_FragColor = v_vColour * texture2D( gm_BaseTexture, v_vTexcoord ); }
  
  Как уже объяснялось, идея фрагментного шейдера заключается в том, чтобы вернуть цвет текущего пикселя. Это делается путем присвоения переменной gl_FragColor конечного значения цвета. Функция texture2D 
    принимает текстуру и vec2 с UV-координатами, которые вы хотите проверить в этой текстуре, и возвращает vec4 с цветом. В проходном шейдере все, что мы делаем, это захватываем цвет
    текстуры в координатах этого пикселя и умножаем его на цвет вершины, связанной с этим пикселем.
  Теперь, когда у нас есть наш первый шейдер, все, что нам нужно сделать для его тестирования, это создать объект и присвоить ему спрайт, затем в событии Draw Event объекта установить шейдер следующим образом:
  // Событие рисования shader_set(shdrColorOverlay);
     draw_self();
     shader_reset();
  
  Каждый вызов рисования, который мы делаем между shader_set() и shader_reset(), будет
    будет применяться шейдер. Здесь мы рисуем спрайт объекта с помощью нашего шейдера passthrough:
  Как вы уже догадались, визуально это ничего не меняет, так как это простой сквозной шейдер.
   шейдер. Однако в следующих разделах описаны некоторые простые шаги, которые вы можете предпринять, чтобы изменить его и изменить способ отрисовки спрайта. Каждый из разделов показывает различные шейдеры, которые вы можете создать и использовать в своих проектах, объясняя шаги, необходимые для их создания, и почему мы это делаем.
    для их создания и почему мы делаем это именно так.
   
   Шейдерналожения цвета
  
    Теперь мы можем отредактировать базовый шейдер, чтобы сделать что-то другое. Мы не будем трогать вершинный шейдер, а отредактируем только фрагментный шейдер , и для начала выполним очень простую операцию, которая заключается в том, чтобы заставить шейдер нарисовать спрайт
      используя красный цвет. Мы сделаем это, просто изменив gl_FragColor на красный цвет, вот так:
    // Фрагментный шейдерналожения цвета void main() {
       gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); }
    
    Это даст нам следующий результат:
    Не совсем то, что мы ожидали! Нам нужно помнить, что каждый спрайт в конечном итоге является прямоугольником,
      поэтому, если не учитывать прозрачность - а мы ее не учитывали, - мы получим именно такой результат.
    ПРИМЕЧАНИЕ: На изображении выше прямоугольник меняет размер, потому что базовый спрайт имеет "пустое" пространство вокруг себя, которое было автоматически обрезано, когда он был помещен на страницу текстуры в GameMaker, поэтому каждый кадр анимации треугольники
      которые его образуют, имеют разный размер, чтобы соответствовать обрезанному размеру кадра. Если отключить эту опцию, то на экране будет просто неподвижный красный квадрат.
    Выше мы упоминали функцию texture2D, и мы будем использовать ее для захвата цвета в пикселе, над которым мы работаем, и получения из него прозрачности. Возвращаемым значением функции texture2D является
      vec4 , где компонентами являются красный, зеленый, синий и альфа-канал, в таком порядке. Мы можем получить доступ к альфа-каналу, поставив точку, за которой следует a или w после имени переменной. Это соответствует RGBA и XYZW, соответственно.
    Вот обновленный код:
    // Фрагментный шейдерналожения цвета изменяющийся vec2 v_vTexcoord;
       void main() {
       vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord); gl_FragColor = vec4(1.0, 0.0, 0.0, texColor.a); }
    
    Теперь мы назначаем новый vec4 на gl_FragColor, где красный канал максимален, зеленый и синий каналы равны нулю, а альфа-канал такой же, как у оригинальной текстуры. Выходные данные выглядят
      вот так:
    Именно этого мы и добивались! Мы заменили цвет каждого пикселя на красный, но сохранили
      альфа-канал остался нетронутым.
    Менять шейдер каждый раз, когда мы хотим использовать другой цвет, - не самая лучшая идея, особенно если учесть, что для каждого цвета нам потребуется отдельный шейдер. Вместо этого мы передадим шейдеру информацию о цвете с помощью формы.
      Для этого нам сначала нужно получить указатель на форму. Мы сделаем это в событии Create нашего объекта, содержащего спрайт, добавив:
    // Создаем событие _uniColor = shader_get_uniform(shdrColorOverlay, "u_colour"); _color = [1.0, 1.0, 0.0, 1.0];
    Все, что нам нужно сделать, это вызвать shader_get_uniform(), чтобы получить указатель на форму. Параметрами, которые нам нужно передать, являются шейдер
      имя актива (без кавычек, потому что мы хотим передать ID, который GameMaker генерирует для нас) и имя переменной униформы внутри шейдера, на этот раз в виде строки. Это имя должно точно совпадать с именем в коде шейдера, чтобы он
      чтобы он работал. Мы также добавили переменную цвета, чтобы мы могли изменять его во время выполнения и чтобы он запомнил наши изменения.
    Теперь код в нашем событии draw немного изменится, чтобы передать переменную uniform.
    // Событие рисования shader_set(shdrColorOverlay);
       shader_set_uniform_f_array(_uniColor, _color); draw_self();
       shader_reset();
    
    Это тот же код, что и раньше, но прежде чем мы нарисуем что-либо, нам нужно передать шейдеру все однородные значения. В данном случае мы передаем цвет как массив плавающих значений. Что касается шейдера, мы изменим его так, чтобы он включал униформу и использовал ее,
      таким образом:
    // Фрагментный шейдерналожения цвета изменяющийся vec2 v_vTexcoord; uniform vec4 u_color; void main() {
       vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord); gl_FragColor = vec4(u_color.rgb, texColor.a); }
    
    Мы объявляем переменную с тем же именем, что и в шейдере create (u_color), и передаем ее в качестве первых трех компонентов вектора gl_FragColor, используя преимущества swizzling. Если мы скомпилируем
      снова, мы увидим следующее:
    Теперь шейдер стал гораздо более полезным и многоразовым. Вам решать, как добавить больше функциональности
      если вам нужно, чтобы он устанавливал цвет (используя переменную _color) во время выполнения.
     
  
  Черно-белый шейдер
  
    Создание черно-белого шейдера - отличный способ узнать больше о том, как работают шейдеры, и многие новички начинают с попытки сделать это, поскольку концептуально это довольно просто: получить каждый пиксель и присвоить ему оттенок серого. Но так ли это просто? Не
      не совсем...
    
    При использовании цвета RGB, если все три компонента имеют одинаковое значение, то мы получаем серый тон. Наивный подход к созданию шейдера для использования этой идеи заключается в том, чтобы сложить все три цветовых канала (красный, зеленый и синий), а затем разделить на три. После
      этого вы присвоили бы значение всем трем каналам, создав таким образом серый тон. Вот как выглядит шейдер фрагмента:
    // Шейдерчерно-белого фрагмента изменяющийся vec2 v_vTexcoord; изменяющийся vec4 v_vColour;
       void main() {
       vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord); float gray = (texColor.r + texColor.g + texColor.b) / 3.0; gl_FragColor = v_vColour * vec4(gray, gray, gray, texColor.a); }
    
    Вы могли заметить, что в коде gl_FragColor мы умножаем vec4 на что-то под названием v_vColour. Это переменная, передаваемая
      вершинным шейдером, которая сообщает нам цвет вершины, связанной с этим пикселем. Всегда полезно умножать конечный вычисленный цвет на цвет вершины. В большинстве случаев это ничего не даст, но если вы изменили цвет вершины в GML,
      это будет отражено (с помощью таких функций, как draw_sprite_ext() или draw_sprite_general() для
      изменить image_blend).
    Что касается события draw, то оно довольно простое, поскольку у нас нет формы для передачи:
    // Событие рисования shader_set(shdrBlackAndWhite);
       draw_self();
       shader_reset();
    
    Давайте скомпилируем и посмотрим, что у нас получилось.
    Это уже выглядит отлично, верно? И да, и нет... Есть решение, которое является более "правильным", поскольку вместо того, чтобы
      вместо сложения компонентов и деления на три, мы умножаем каждый компонент на стандартные значения NTSC для черного и белого. Вот измененный код фрагментного шейдера:
    // Шейдерчерно-белого фрагмента изменяющийся vec2 v_vTexcoord;
       void main() {
       vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord); float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114)); gl_FragColor = vec4(gray, gray, gray, texColor.a); }
    
    Мы используем точечное произведение как сокращение для умножения каждого компонента texColor с правильными весами, а затем складываем их вместе. Если вы не знакомы с точечным произведением, то, по сути, происходит следующее:
    float gray = (texColor.r * 0.299) + (texColor.g * 0.587) + (texColor.b * 0.114);
    В конечном итоге, это выглядит очень похоже, но технически более правильно.
    
     
  
  Радужный шейдер
  
    Наш последний пример шейдера - это забавный пример, который можно использовать для придания жизни тексту, кнопкам и другим вещам. Мы начнем с простого и будем постепенно добавлять функциональность, поскольку этот шейдер очень настраиваемый. В этом примере мы рассмотрим довольно много вопросов,
      поэтому если вы чувствуете себя немного потерянным или запутавшимся, пожалуйста, вернитесь назад и перечитайте некоторые разделы выше.
    Первое, что мы хотим сделать, - это окрасить пиксели в любой оттенок в зависимости от горизонтального положения пикселя. Для этого нужно установить положение x в качестве оттенка, а затем преобразовать формат HSV (оттенок, насыщенность, яркость) в формат RGB (красный, зеленый,
      и синий). Для этого нам нужно написать вспомогательную функцию в шейдере фрагмента, которая принимает значения HSV и возвращает вектор RGB. Мы будем использовать одну функцию, которая делает это без необходимости использования каких-либо операторов if,
      поскольку использование условий в коде шейдера делает шейдеры очень медленными, и его следует избегать.
    Вот как выглядит шейдер на данном этапе:
    // Фрагментный шейдер изменяющийся vec2 v_vTexcoord; изменяющийся vec4 v_vColour;
       vec3 hsv2rgb(vec3 c)  {
       vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }
      
       void main() {
       vec3 col = vec3(v_vTexcoord.x, 1.0, 1.0); float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a; gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha); }
    
    Здесь происходит немного больше событий, чем в предыдущих примерах, но большинство из них должно быть достаточно очевидным для вас. Во-первых, есть наша функция hsv2rgb, которая принимает vec3 с нашим цветом HSV
      и возвращает другой vec3 с нашим преобразованием в RGB. В основной функции мы начинаем с создания нашего цвета HSV, где оттенок - это наша позиция x, а насыщенность и яркость мы пока оставим равными 1.0. Затем мы получаем
      альфа из текстуры, чтобы она окрашивала только наш персонаж, а не весь прямоугольник спрайта (как мы делали в примере наложения цветов выше). Наконец, мы задаем цвет фрагмента как цвет HSV, преобразованный в RGB с альфой и умноженный
      на цвет вершины (хорошая практика - делать это всегда).
    Что касается нашего кода для рисования, то на данный момент он тривиален:
    // Событие рисования shader_set(shdrRainbow);
       draw_self();
       shader_reset();
    
    Давайте проверим, что мы получили:
    Мы близки к тому, что хотим, но есть проблема: мы не видим все цвета одновременно в каждом кадре
      анимации, и кажется, что цвета меняются случайным образом. Причина в том, что мы предположили, что v_vTexcoord дал нам координаты спрайта, начинающиеся в левом верхнем углу (0,0) и заканчивающиеся в правом нижнем углу
      (1,1), что является стандартным для шейдеров. Однако для оптимизации GameMaker запихивает столько текстур вместе, сколько может поместиться в так называемую текстурную страницу, и поэтому вот так
      вот как на самом деле выглядит наша текстура:
    Как объяснялось выше, v_vTexcoord дает нам абсолютные координаты спрайта в пределах всей страницы текстуры,
      но нам нужно значение от 0.0 до 1.0, которое охватывает только наш текущий спрайт. Этот процесс называется нормализацией (получение значения и перевод его в диапазон от 0 до 1). Чтобы нормализовать наши горизонтальные значения, нам нужно знать
      значения x0 и x1 на рисунке выше. К счастью, в GameMaker есть функция, которая позволяет определить расположение каждого угла в нашем спрайте на странице текстуры. Сначала нам нужно перейти к событию Create Event и создать форму для передачи этих данных в
     шейдеру:
    // Создаем событие _uniUV = shader_get_uniform(shdrRainbow, "u_uv");
    И мы изменяем событие draw, чтобы получить значения и затем передать их шейдеру:
    // Событие рисования shader_set(shdrRainbow);
       var uv = sprite_get_uvs(sprite_index, image_index); shader_set_uniform_f(_uniUV, uv[0], uv[2]); draw_self();
       shader_reset();
    
    Функция sprite_get_uvs() принимает спрайт и индекс, и возвращает массив с массой информации,
      например, координаты каждого угла, сколько пикселей было обрезано для оптимизации и т.д. Нас интересуют два из этих значений: левая и правая координаты спрайта, которые хранятся в uv[0] и uv[2] соответственно. В шейдере фрагмента мы будем использовать эти значения для вычисления нормализованной горизонтальной позиции следующим образом:
    // Fragment Shader varing vec2 v_vTexcoord; varing vec4 v_vColour;
       uniform vec2 u_uv;
       vec3 hsv2rgb(vec3 c)  {
       vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }
      
       void main() {
       float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]); vec3 col = vec3(pos, 1.0, 1.0); float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a; gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha); }
    
    Здесь мы добавляем однородную переменную в верхней части файла с тем же именем, которое мы использовали в событии Create Event. Далее мы вычисляем нормализованную горизонтальную позицию, переводя нашу текущую координату x в начало координат (
      v_vTexcoord.x - u_uv[0] ), а затем делим ее на ширину спрайта, чтобы получить диапазон от 0 до 1 (u_uv[1] - u_uv[0]).
    В результате:
    Вот так! Это именно то, что мы хотели. Мы можем видеть каждый цвет спектра внутри
      нашего спрайта.
    Вы можете быть довольны этим, но мы можем еще немного поразвлечься с этим шейдером. Что если мы добавим смещение цветов, основанное на времени, чтобы создать движение? Для этого нам понадобятся две дополнительные переменные для скорости и времени.
      Нам также понадобятся еще две формы, по одной для каждой из новых переменных, так что событие Create Event станет:
    // Создание события _uniUV = shader_get_uniform(shdrRainbow, "u_uv"); _uniTime = shader_get_uniform(shdrRainbow, "u_time"); _uniSpeed = shader_get_uniform( shdrRainbow, "u_speed"); _time = 0; _speed = 1.0;
    Нам также необходимо увеличивать время на каждом кадре, поэтому в событии Step Event мы добавляем:
    // Шаг события _time += 1 / room_speed;
    Давайте теперь перейдем к событию draw, чтобы отправить эти формы в шейдер:
    // Событие рисования shader_set(shdrRainbow);
       var uv = sprite_get_uvs(sprite_index, image_index); shader_set_uniform_f(_uniUV, uv[0], uv[2]); shader_set_uniform_f(_uniSpeed, _speed); shader_set_uniform_f(_uniTime, _time); draw_self();
       shader_reset();
    
    Наконец, мы вернемся к нашему шейдеру, чтобы фактически использовать эти переменные. Мы умножим скорость на время и добавим это к положению, как показано ниже:
    // Fragment Shader varing vec2 v_vTexcoord; varing vec4 v_vColour;
       uniform vec2 u_uv; uniform float u_speed; uniform float u_time;
       vec3 hsv2rgb(vec3 c)  {
       vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }
      
       void main() {
       float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]); vec3 col = vec3((u_time * u_speed) + pos, 1.0, 1.0); float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a; gl_FragColor = v_vColour * vec4(hsv2rgb(col),
      alpha);
       }
    
    Если вы все сделали правильно, вы должны увидеть что-то вроде этого:
    Чтобы завершить этот шейдер, мы добавим еще несколько форм для его дальнейшей настройки.
      Первые две будут управлять насыщенностью и яркостью. Следующую мы назовем "секция", и ее функция заключается в том, чтобы позволить пользователю передать число от нуля до единицы, чтобы определить, какой процент всего спектра мы видим за
      время. Наконец, мы добавим переменную "mix", которая будет определять, насколько мы хотим смешать цвет шейдера с цветом оригинальной текстуры (1.0 - вся радуга, 0.0 - вся текстура). Как обычно, давайте начнем с добавления переменных в
      событие Create Event:
    // Создание события _uniUV = shader_get_uniform(shdrRainbow, "u_uv"); _uniTime = shader_get_uniform(shdrRainbow, "u_time"); _uniSpeed = shader_get_uniform( shdrRainbow, "u_speed"); _uniSection
         = shader_get_uniform(shdrRainbow, "u_section"); _uniSaturation = shader_get_uniform(shdrRainbow, "u_saturation");  _uniBrightness = shader_get_uniform( shdrRainbow, "u_brightness"); _uniMix =
     shader_get_uniform(shdrRainbow, "u_mix");
       _time = 0; _speed = 1.0; _section = 0.5; _saturation = 0.7; _brightness = 0.8; _mix = 0.5;
    В ходе жеребьевки мы меняем униформу таким образом:
    // Событие рисования shader_set(shdrRainbow);
       var uv = sprite_get_uvs(sprite_index, image_index); shader_set_uniform_f(_uniUV, uv[0], uv[2]); shader_set_uniform_f(_uniSpeed, _speed); shader_set_uniform_f(_uniTime, _time);  shader_set_uniform_f(_uniSaturation, _saturation); shader_set_uniform_f(_uniBrightness, _brightness); shader_set_uniform_f(_uniSection, _section); shader_set_uniform_f(_uniMix, _mix); draw_self();
       shader_reset();
    
    Что касается шейдера, нам нужно передать насыщенность и яркость в цвет, что повлияет на цвет, генерируемый нашей вспомогательной функцией. Отрезок нужно умножить на нашу позицию, чтобы уменьшить диапазон. Мы также захватим всю текстуру
      цвет, чтобы мы могли вычислить наш окончательный цвет, смешав цвет текстуры с RGB-преобразованием нашего цвета. Последний параметр функции mix определяет, сколько второго цвета мы хотим добавить. Это наш окончательный код шейдера:
    // Fragment Shader varying vec2 v_vTexcoord; varying vec4 v_vColour;
       uniform vec2 u_uv; uniform float u_speed; uniform float u_time; uniform float u_saturation; uniform float u_brightness; uniform float u_section; Uniform float u_mix;
       vec3 hsv2rgb(vec3 c)  {
       vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }
      
       void main() {
       float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]); vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);       vec3 col = vec3(u_section * ((u_time * u_speed) + pos), u_saturation, u_brightness); vec4 finalCol = mix(texColor, vec4(hsv2rgb(col), texColor.a), u_mix);      gl_FragColor = v_vColour * finalCol; }
    
    И наш конечный результат таков!
    
     
  
   
  На этом мы заканчиваем это краткое руководство, и теперь вы должны лучше понимать, как работают шейдеры и как их можно использовать. Не спешите играть с шейдерами, которые вы создали, следуя этому руководству, и попробуйте
    поэкспериментируйте с ними и сделайте другие вещи - как насчет создания шейдера размытия или шейдера, который делает монохромный экран в стиле Gameboy? - поскольку шейдеры - это невероятно мощный инструмент для добавления визуальной сложности и стиля в ваши игры.
   
  КомпанияYoYo Games выражает благодарность Алехандро Хитти и Amazon за разрешение воспроизвести это руководство. Оригинальную версию можно найти в блоге разработчиковAmazon.
   
  
    
      
        Назад: Дополнительная информация
        Следующий: Руководство по примитивам и построению вершин
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

