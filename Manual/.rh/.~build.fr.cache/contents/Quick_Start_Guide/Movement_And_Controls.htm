
  
  Движение и управление
  В предыдущем разделе этого Краткого руководства были приведены некоторые примеры рисования объектов на экране, но просто рисовать объекты не очень хорошо, если вы не можете их перемещать... поэтому в этом разделе мы приведем несколько примеров перемещения объектов, а также некоторые основные схемы управления в различных типах игр.
    примеры перемещения объектов, а также некоторые базовые схемы управления для различных типов игр. Все примеры приведены с использованием Drag and Drop™(DnD™), а также языка GameMaker Language(GML), поэтому вы можете использовать тот из них, который вам более удобен.
    удобнее. Обратите внимание, что мы не будем объяснять здесь все слишком подробно, поскольку хотим, чтобы вы как можно быстрее приступили к созданию игры, поэтому мы рекомендуем вам изучать все ссылки по ходу работы и использовать функцию "поиск" в руководстве для поиска дополнительной информации.
    в руководстве для поиска дополнительной информации о том, в чем вы не уверены.
  Прежде чем двигаться дальше, вы можете создать новый проект ( GML или DnD™) на стартовой странице, добавить (или создать) несколько спрайтов, а также один или два объекта - поскольку мы дадим вам некоторый
    и убедитесь, что в проекте есть комната, в которой можно разместить объекты. Не слишком заботьтесь о том, как выглядят создаваемые вами спрайты - подойдет даже простой белый квадрат.
    вы можете приступить к работе над примерами, приведенными ниже.
   
  Двигайтесь по направлению к мыши
  
    Одним из самых простых способов заставить объект двигаться и взаимодействовать с игроком является использование мыши, и в этом примере мы покажем вам, как с помощью базового кода заставить объект двигаться туда, где пользователь нажал левую кнопку мыши.
       .
    Для начала откройте объект, назначьте ему спрайт, а затем дайте ему глобальное событие Left Mouse Down:
    
    Мы используем глобальные события мыши, поскольку они обнаруживают щелчок в любой точке комнаты, в то время как обычные события мыши обнаруживают щелчок только в том случае, если мышь действительно щелкает в пределах ограничительной области экземпляра. В этом событии мы хотим добавить это DnD™или GML:
    
    move_towards_point(mouse_x, mouse_y, 2);
    Здесь мы указываем экземпляру двигаться к позиции на экране, в данном случае к позициям "mouse_x" и "mouse_y" ("mouse_x"
      и "mouse_y" - это встроенные переменные  , которыевсегда хранят текущее положение курсора мыши). DnD™
      делает это, устанавливая "direction" и " speed" Переменные экземпляра,
      в то время как GML делает это с помощью функции move_towards_point() (она также устанавливает переменные speed и
      direction  , только в одной, простой в использовании функции).
    Поместите экземпляр этого объекта в комнату и нажмите кнопку Play , затем щелкните мышью  по комнате.
      по комнате, чтобы заставить объект двигаться в направлении мыши:
    Отлично! Экземпляр объекта теперь перемещается в направлении, где вы щелкнули, и если вы удерживаете кнопку нажатой, экземпляр
      будет продолжать следовать за курсором мыши. Однако есть проблема... После того как вы щелкните один раз и отпустите кнопку, объект продолжит движение и в конце концов покинет комнату! Есть несколько способов решить эту проблему, и какой из них вы выберете, зависит от того.
      будет зависеть от того, что вы хотите сделать, но самым простым на данный момент является простое добавление события Global Mouse Button Released, поэтому добавьте его к объекту и задайте следующий код:
    
    скорость = 0;
    При этом экземпляр будет следовать за курсором мыши только до тех пор, пока удерживается кнопка мыши, а когда вы отпустите кнопку, он перестанет двигаться. Нажмите Play  и протестируйте его прямо сейчас.
    Прежде чем мы оставим этот пример, необходимо решить еще один вопрос... Если нажать и удерживать кнопку мыши, но не перемещать курсор, то экземпляр будет двигаться к курсору, а затем "вибрировать" вокруг него.
      Это происходит потому, что экземпляр движется быстрее, чем на 1 пиксель за раз, и поэтому "перебегает" позицию, а затем пытается вернуться назад, затем снова перебегает и т.д... (сделайте скорость движения 5 или что-то вроде этого, чтобы увидеть проблему, если
      если она не очевидна сразу).
    Чтобы решить эту проблему, мы должны добавить событие Step Event к объекту с помощью этого кода:
    
    var _dist = point_distance(x, y, mouse_x, mouse_y); if _dist <= speed { speed = 0; }
    Здесь мы просто проверяем расстояние от экземпляра до позиции мыши, и если оно равно или меньше текущей скорости, мы устанавливаем скорость на 0. Это заставляет экземпляр останавливаться, когда он достаточно близко к позиции мыши, и мы не получаем
      получить неприятную проблему "вибрации".
     
  
  4- и 8-стороннее движение с помощью клавиатуры
  
    Всамом начале этого руководства мы показали вам следующий код DnD™и GML для перемещения экземпляра вправо на два пикселя каждый игровой шаг:
    
    x = x + 2;
    Этот тип перемещения называется позиционным перемещением, поскольку мы, по сути, поднимаем экземпляр и снова помещаем его в новое положение каждый раз, когда выполняется код. В этом примере мы покажем, как
      использовать этот тип движения для перемещения экземпляра в четырех направлениях: вверх, вниз, влево и вправо.
    Для начала откройте объект и назначьте ему спрайт. Теперь мы могли бы добавить различные события клавиатуры, и в каждом из них заставить объект двигаться в нужном направлении, однако мы хотим, чтобы игрок мог двигаться только
      в одном направлении за раз, и сделать это с помощью только событий клавиатуры немного сложнее, чем с помощью кода. Вместо этого мы будем использовать событие Step (Шаг), которое вы должны добавить к объекту, с помощью следующих действий
     DnD™или GML для использования клавиш со стрелками для перемещения:
    
    if keyboard_check(vk_left) { x = x - 2; }  else if keyboard_check(vk_right) { x = x + 2; }  else if keyboard_check(vk_up) { y = y - 2; }  else if keyboard_check(vk_down) { y = y - 2; }
    Мы используем структуру " if... else if... else if...", чтобы гарантировать, что экземпляр будет двигаться только в одном направлении за один раз, поэтому экземпляр должен иметь возможность двигаться только вверх, вниз, влево или вправо, но не
      по диагонали. Поместите экземпляр объекта в комнату и нажмите кнопку Play  , чтобы протестировать его прямо сейчас! Если все прошло правильно, у вас должно получиться нечто
      примерно следующее:
    
    Мы можем легко модифицировать этот код для преобразования 4-стороннего движения в 8-стороннее... просто удалите команды " else" из блоков кода, чтобы все выглядело следующим образом:
    
    if keyboard_check(vk_left) { x = x - 2; }  if keyboard_check(vk_right) { x = x + 2; }  if keyboard_check(vk_up) { y = y - 2; }  if keyboard_check(vk_down) { y = y - 2; }
    Теперь, когда вы нажмете кнопку Play  , это будет выглядеть примерно так:
    
    И последнее, на что стоит обратить внимание пользователям, работающим с GML.. . При использовании DnD™вы можете выбрать клавишу клавиатуры, которую вы хотите использовать, из выпадающего списка, но с GML все не так просто. Существует ряд констант клавиатуры, которые
      которые можно использовать - например, константы клавиш со стрелками, показанные в приведенном выше коде, - но нет констант для буквенно-цифровых клавиш. Они обрабатываются несколько иначе и требуют использования функции ord().
      В приведенном ниже коде показано, как это будет работать, если вместо клавиш со стрелками использовать WASD:
    if keyboard_check(ord("A")) { x = x - 2; }  if keyboard_check(ord("D")) { x = x + 2; }  if keyboard_check(ord("W")) { y = y - 2; }  if keyboard_check(ord("S")) { y = y - 2; }
     
  
  Движение геймпада
  
    Мы рассмотрели движение мыши и клавиатуры, а значит, пришло время рассказать о движении геймпада. Теперь мы не будем рассматривать d-pad, поскольку он работает точно так же, как и клавиатура (просто измените функции клавиатуры в приведенном выше примере).
      в приведенном выше примере на gamepad_button_check() или If Gamepad button Down),
      Поэтому в этом примере мы рассмотрим использование аналогового стика для перемещения.
    Для начала нам нужно определить используемый геймпад. Геймпадам присваивается значение ID от 0 до 11, поэтому мы будем использовать цикл " for" для определения ID всех подключенных геймпадов и сохранения значения ID в переменной
      для дальнейшего использования. Поскольку мы хотим определить только первый подключенный геймпад, а не все, мы будем использовать команду " break" после обнаружения геймпада, чтобы "разорвать" цикл (например, если первый геймпад подключен к компьютеру).
      например, если первый подключенный геймпад имеет ID 4, то цикл будет выполняться только 5 раз, проверяя значения ID 0 - 4, а затем выходя из цикла при обнаружении геймпада). Итак, создайте (или откройте) объект, назначьте ему спрайт, а затем добавьте
     событие Create Event со следующими параметрами:
    
    gamepad_id = -1; for (var i = 0; i < 12; i += 1;) { if gamepad_is_connected(i) { gamepad_id = i; gamepad_set_axis_deadzone(gamepad_id, 0.2); break; }  }
    
    Обратите внимание, что в приведенном выше коде мы установили  deadzone для геймпада. Это связано с тем, что аналоговые стики на разных моделях геймпадов имеют разную чувствительность, и иногда
      они могут быть настолько чувствительными, что если вы не установите мертвую зону, то они могут вызвать нежелательные движения в ваших играх. Поэтому мы устанавливаем мертвую зону на значение 0,2, чтобы указать GameMaker Studio 2 игнорировать любые значения стиков геймпада ниже этого абсолютного значения.
    Чтобы добавить собственно движение, нам понадобится событие Step Event, поэтому добавьте его сейчас и дайте ему следующее название DnD™ или GML:
    
    if gamepad_id > -1 { var _h = gamepad_axis_value(gamepad_id, gp_axislh); var _v = gamepad_axis_value(gamepad_id, gp_axislv); x += _h * 4; y += _v * 4; }
    Здесь мы проверяем левый стик на горизонтальное или вертикальное движение. Функции оси возвращают значение от -1 до 1, поэтому для горизонтальной оси -1 - это движение влево, 0 - не движение и 1 - вправо, а для вертикальной оси -1 - вверх, 0 - не движение и 1 - вниз.
      вверх, 0 - не движется и 1 - вниз. Обратите внимание, что значения находятся между -1 и 1, поэтому, например, горизонтальная ось может вернуть значение 0,5, что означает, что стик находится на полпути между положением "покоя" и полностью сдвинут
      вправо. По этой причине мы умножаем значение на 4 (можно умножить на любое значение, в зависимости от скорости, с которой должен двигаться экземпляр) - это означает, что скорость экземпляра будет меняться в зависимости от того, насколько сильно было сделано движение
      было сделано по оси стика.
    Поместите экземпляр этого объекта в комнату и нажмите кнопку Play .  а затем перемещайтесь по комнате с помощью левого стика вашего подключенного
      геймпада. Вы должны увидеть что-то вроде этого:
    
     
  
  Усовершенствованное 8-стороннее движение
  
    В этом последнем примере мы рассмотрим наш код движения по 8 направлениям и решим проблему, связанную с тем, что движение по диагонали на самом деле быстрее, чем движение вверх/вниз/влево/вправо. Это просто потому, что при движении по диагонали вы двигаетесь
      по гипотенузе прямоугольного треугольника, созданного значениями перемещения x/y:
    
    Чтобы было понятнее, что происходит, давайте уберем весь текст и спрайты и просто покажем ту же линию движения, повернутую на 45°, чтобы она была горизонтальной:
    
    Как видите, разница довольно очевидна, а если экземпляр перемещается более чем на 1-2 пикселя за шаг, то становится очень заметно, что диагональное движение намного быстрее! Как же это ограничить? Есть несколько способов
      но мы остановимся только на одном из них, потому что он вводит несколько функций и концепций, которые пригодятся вам в дальнейшем в ваших играх.
    Чтобы справиться с этим, нам придется хранить входные значения от нажатых клавиш независимо друг от друга в переменных, а затем проверять их и перемещать в соответствии с
      в соответствии с комбинацией нажатых клавиш. Итак, для этого вам понадобится объект с назначенным спрайтом, и вам нужно будет дать ему событие Step Event со следующим DnD™ илиGML:
    
    ПРИМЕЧАНИЕ: Мы разделили вышеприведенный текст DnD™ на две колонки, чтобы его было легче визуализировать, но в редакторе DnD™ он будет располагаться последовательно.
    var _left = keyboard_check(vk_left); var _right = keyboard_check(vk_right); var _up = keyboard_check(vk_up); var _down = keyboard_check(vk_down); var _hspd = _right - _left; var _vspd = _down - _up;
    Нам нужно будет добавить еще немного кода, чтобы действительно двигаться, но прежде давайте немного объясним это. Мы хотим преобразовать движения влево/вправо/вверх/вниз в эквивалентные значения скорости по горизонтали и вертикали, поэтому для этого мы получим значение каждой из клавиш
      клавиши, а затем выполняем некоторые математические операции, чтобы получить значения скорости. Это работает потому, что если клавиша нажата, то действие или функция проверки вернет "1", а если она не нажата, то функция вернет "0".
      0. Таким образом, если, например, нажата правая клавиша, вы получите "1 - 0 = 1" для " _hspd", а если нажата левая, вы получите "0 - 1 = -1" для " _hspd".
      (а если они оба нажаты, то будет "1 - 1 = 0", поэтому экземпляр не будет двигаться). Помните, что в комнате GameMaker Studio 2 для перемещения вправо мы прибавляем к позиции x , а для перемещения влево - вычитаем, так что этот
      код даст нам положительное или отрицательное значение, которое мы можем прибавить или отнять для перемещения по горизонтали или вертикали в зависимости от ввода с клавиатуры.
    Теперь мы можем добавить код, который фактически перемещает экземпляр, поэтому - все еще в событии Step Event, и после вышеуказанного кода - добавьте следующее:
    
    if (_hspd != 0 || _vspd != 0) { var _spd = 4; var _dir = point_direction(0, 0, _hspd, _yspd); var _xadd = lengthdir_x(_spd, _dir); var _yadd = lengthdir_y(_spd, _dir); x = x + _xadd; y
      = y + _yadd; }
    Приведенный выше код сначала проверяет, истинно ли одно из двух выражений, т.е. если переменные горизонтальной или вертикальной скорости не равны 0. Обратите внимание, как в "
      if " в GML используется символ " ||". В программировании это означает " or", поэтому - на обычном языке - вы проверяете
    если переменная _hspd не равна нулю или если переменная _vspd не равна нулю
    Таким образом можно объединить несколько выражений в проверки " if", и существует несколько различных способов оценки этих выражений (для получения дополнительной информации см. раздел "Выражения" здесь ).
    Следующий раздел кода хранит значение фактической скорости движения в переменной, а затем получает направление, используя значения _hspd и _vspd , которые могут быть равны -1, 0 или 1. Функция направления
      проверяет направление от (0, 0), поскольку мы не используем комнатные координаты, а хотим, чтобы она оценивала направление от 0° до 360° на основе значений переменных. Следующая диаграмма иллюстрирует происходящее лучше, чем попытка объяснить это словами.
      словами:
    
    ПРИМЕЧАНИЕ: Направление в GameMaker Studio 2 рассчитывается против часовой стрелки, поэтому 0° и 360° находятся справа, 90° - вверх, 180° - вправо и 270° - вниз.
    Наконец, мы используем lengthdir_x() и lengthdir_y() функции
      для фактического перемещения переменной. Это  вектор  функции, которые принимают длину (расстояние) и направление, а затем вычисляют новое положение на заданной оси, основываясь на этих
      (более подробное объяснение см. в описании функций).
    Это очень много, и не волнуйтесь, если вы еще не все поняли! Со временем вы поймете! Теперь осталось только добавить экземпляр этого объекта в комнату, а затем нажать кнопку Play  ,
      и вы получите шелковисто-гладкое движение в 8 направлениях без каких-либо проблем, связанных с движением по диагонали:
    
  
   
  Мы надеемся, что эти примеры - и предыдущие примеры для рисования - достаточно понятны вам, чтобы начать создавать свои собственные проекты! На последней странице этого Краткого руководства содержится краткий обзор того, что вы узнали, а также ссылки на дополнительные учебные материалы.
    а также ссылки на дополнительные учебные материалы.
   
   
  
    
      
        Назад: Указатель
        Следующее: Резюме
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

