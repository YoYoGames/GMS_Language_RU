
  
  Рисование
  Цель этого раздела (и следующего раздела " Движение и управление") - дать вам практические примеры использования GML или DnD™, чтобы вы могли как можно быстрее приступить к созданию своих первых игровых проектов. Мы
    мы не будем объяснять все слишком подробно, так как хотим, чтобы вы как можно быстрее приступили к созданию игры, поэтому мы рекомендуем вам изучать все ссылки по ходу дела и использовать функцию "поиск" в руководстве для поиска дополнительной информации.
    информацию о том, в чем вы не уверены.
  В этом разделе мы сконцентрируемся на простом рисовании информации на экране, как в виде текста, так и в виде изображений, а также расскажем немного больше о различных событиях Draw , в частности, об основном событии Draw
    и событие Draw GUI (обратите внимание, что в некоторых примерах вам потребуется добавить другие события, но мы будем объяснять их по мере того, как мы до них дойдем).
  
  Прежде чем продолжить, вам, возможно, захочется создать новый проект (либо GML, либо DnD™) на стартовой странице и добавить (или создать) несколько спрайтов, а также объект или два, поскольку мы будем давать вам некоторые
    код, который вы сможете протестировать с их помощью. В качестве спрайта для нашего объекта пока подойдет даже белый квадрат!
  Как уже упоминалось в разделе " Объекты и экземпляры", если вы не добавите к объекту событие Draw Event, то GameMaker Studio 2 будет рисовать по умолчанию, то есть, если объекту назначен спрайт, то этот спрайт будет нарисован по умолчанию.
    спрайт будет нарисован, причем с любыми добавленными преобразованиями. Что мы имеем в виду под трансформациями? Каждый объект имеет ряд встроенных переменных, которые управляют тем, как экземпляр объекта рисует свой спрайт при стандартном рисовании, и вы можете изменять эти переменные по ходу игры, чтобы изменить способ рисования спрайта.
  ПРИМЕЧАНИЕ: Список всех встроенных переменных, которые можно использовать для преобразования спрайтов экземпляра, можно найти здесь.
    Пользователи Drag and Drop™имеют некоторые специальные действия, влияющие на эти переменные, которые вы можете найти здесь, а также вы можете использовать сами переменные вместе с действиями
    действиями Get Instance Variable и Set Instance Variable.
  Давайте рассмотрим несколько примеров:
  Изменение альфа (прозрачности)
  
     Альфа-значение управляет прозрачностью рисуемого объекта, и в GameMaker Studio 2 вы можете использовать встроенную переменную image_alpha, чтобы изменить прозрачность назначенного спрайта. Чтобы
      увидеть, как это работает, откройте (или создайте) объект, назначьте ему спрайт, а затем передайте объекту событие Create Event. В событии Create Event просто добавьте следующий текст DnD™или GML:
    
    var _val = random(1); image_alpha = _val;
    Альфа изображения рассчитывается как значение от 0 до 1, где 0 - полностью прозрачное, а 1 - полностью непрозрачное (по умолчанию установлено значение 1). Поэтому в данном примере мы просто устанавливаем альфа-фактор изображения в случайное десятичное значение от 0 до 1. Разместите
      несколько экземпляров этого объекта в комнате, а затем нажмите кнопку Play   в верхней части IDE.
    Вы должны увидеть, что каждый экземпляр объекта рисует свой спрайт с разной прозрачностью, например:
    
     
  
  Изменение цветовой гаммы (тонирование)
  
    Когда ваш объект по умолчанию рисует спрайт, этот спрайт на самом деле рисуется смешанным (или тонированным) цветом, и значение этого цвета хранится во встроенной переменной image_blend.
      По умолчанию этот цвет белый, что означает, что при отображении спрайта на экране цвет не добавляется. Однако вы можете использовать другие цвета для достижения специальных эффектов, например, использовать красный цвет, чтобы показать, что экземпляр получил
      некоторые повреждения.
    В этом примере мы собираемся смешивать различные цвета со спрайтом при нажатой и удерживаемой клавише, поэтому вам нужно открыть (или создать) объект, назначить ему спрайт, а затем присвоить объекту событие Key Down <Space>.
    
    В этом событии Key Down Event добавьте следующий DnD™или GML:
    
    var _col = choose(c_red, c_green, c_blue, c_yellow, c_fuchsia, c_orange); image_blend = _col;
    Разместите несколько экземпляров этого объекта в комнате, а затем нажмите кнопку Play  в верхней части IDE и протестируйте, удерживая и отпуская клавишу Space . Вы
      должны увидеть, что каждый экземпляр будет быстро менять свой цвет, пока клавиша удерживается, и перестанет меняться, когда клавиша будет отпущена:
    
     
  
  Изменение масштаба
  
    Еще одним свойством, которое мы можем изменить для нашего спрайта, является значение масштаба , позволяющее нам рисовать его больше или меньше, когда мы захотим. Масштаб определяется независимо по осям X и Y двумя отдельными переменными, переменной
      image_xscale и image_yscale. По умолчанию они установлены в 1, и действуют как множители, так что значение 0,5 будет половиной масштаба, а значение 2 - удвоением масштаба.
    ВАЖНО! Изменение назначенного масштаба спрайта с помощью этих переменных также изменит размер ограничивающей рамки, что означает, что область обнаружения столкновений для спрайта также изменится.
    В этом примере мы будем использовать простую математику, чтобы заставить экземпляр масштабировать спрайт вверх и вниз в цикле. Для начала откройте (или создайте) объект, назначьте ему спрайт, а затем передайте объекту событие Create Event. В этом
      событие добавьте следующее:
    
    таймер = 0;
    Теперь добавьте событие Step Event к объекту с помощью этого:
    
    timer = timer + 1; var _val = dsin(timer); image_xscale = 1 + _val; image_yscale = 1 + _val;
    Здесь мы используем функцию maths dsin() для создания значения между -1 и 1 с помощью переменной таймера, а затем применяем его
      это значение к переменным масштаба. После размещения нескольких экземпляров в комнате и нажатия кнопки Play   вы должны увидеть, как экземпляры масштабируются вверх и
      от масштаба 0 до масштаба 2, а затем обратно.
    
    И последнее... измените раздел " image_yscale" на " 1 - _val" и посмотрите, что получится!
     
  
   
  Приведенные выше примеры иллюстрируют лишь некоторые из множества способов манипулирования спрайтом объекта, когда GameMaker Studio 2 рисует по умолчанию, но как быть, если вы хотите нарисовать несколько объектов? В таких случаях необходимо использовать событие Draw Event, чтобы явно указать GameMaker Studio 2, что рисовать, что мы и сделаем в следующих примерах.
  Рисование двух (или более) спрайтов вместе
  
    Для этого примера вам понадобятся два спрайта и один объект. Назовите спрайты " spr_One" и " spr_Two", затем установите для " spr_One"
      начало координат в центре, а для " spr_Two" установите его начало координат в середине слева:
    Назначьте первый спрайт (" spr_One" с центром начала координат) на созданный объект, а затем добавьте
      событие CreateEvent. В событии Create Event добавьте следующий текст DnD™или GML:
    
    draw_angle = 0;
    Мы собираемся использовать эту переменную для поворота " spr_Two" во времени и нарисовать его наложенным на спрайт, назначенный объекту (" spr_One"). Для этого нам нужно добавить событие Draw Event к
      объекту. Этим мы сообщаем GameMaker Studio 2, что хотим взять на себя управление процессом рисования объекта, что означает, что наш код будет включать вызов функции draw_self() функция
      или Нарисовать себя действие. Это действие просто повторяет действия объекта, когда событие Draw Event отсутствует, и по умолчанию он рисует назначенный спрайт. Мы
      затем нарисуем второй спрайт, который мы хотим использовать в качестве вращающегося спрайта наложения. DnD™и GML выглядят следующим образом:
    
    draw_self(); draw_angle = draw_angle + 0.5; draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    Добавьте несколько экземпляров объекта в редактор комнаты, а затем нажмите кнопку Play   в верхней части IDE. Если все прошло правильно, вы должны увидеть что-то вроде этого:
    
    Прежде чем мы оставим этот пример, давайте немного подправим его, и вместо того, чтобы просто вращать " spr_Two", мы сделаем так, чтобы он был направлен на позицию мыши. Для этого нам нужно изменить событие Draw Event
     DnD™или GML, чтобы оно выглядело следующим образом:
    
    draw_self(); draw_angle = point_direction(x, y, mouse_x, mouse_y); draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    Запустите проект снова, и на этот раз вы увидите нечто совсем другое!
    Спрайт теперь направлен в сторону мыши, независимо от того, куда вы его переместили! Как вы можете видеть, наложение спрайтов - это отличный
      способ добавить детали к объекту или заставить что-то двигаться независимо от "базового" спрайта, назначенного объекту, и это мощный инструмент, который вы наверняка будете часто использовать в своих проектах.
     
  
  Рисование вещей, отличных от спрайтов
  
    В событии Draw Event можно рисовать не только спрайты, но и другие объекты, например текст или фигуры. В этом примере мы используем функцию DnD™ или GML draw_self() для рисования спрайта объекта, но мы также нарисуем некоторые другие вещи,
      начиная с текста. Для этого примера вам понадобится спрайт и объект (с назначенным ему спрайтом). В объекте сначала добавьте событие Create Event с этим DnD™или GML:
    
    имя = выбрать("Фред", "Джонас", "Шэрон", "Кейт", "Фрэнк", "Джон", "Моника", "Аманда"); число = irandom(100);
    Это означает, что GameMaker Studio 2 должна выбрать одно из перечисленных имен и присвоить его переменной, а также сгенерировать случайное число от 0 до 100 для каждого экземпляра объекта. Мы хотим вывести эти значения на экран, поэтому для этого
      теперь нужно добавить событие Draw Event и в нем добавить следующее DnD™или GML:
    
    draw_self(); draw_set_halign(fa_center);
       draw_text(x, y + 32, "My name is " + name); draw_text(x, y + 48, "My number is " + string(number));
    В приведенном выше коде вы заметите, что мы используем string() функция или Число в строку действие
      на переменной "number", которую мы хотим нарисовать. Это потому, что весь текст должен состоять из символов, а не из значений, и поэтому нам нужно использовать эту функцию/действие для преобразования значения числа в те символы, которые мы хотим
      нарисовать. В данном случае мы берем сгенерированное нами случайное число и превращаем его в "строку" символов, которые можно нарисовать. Также обратите внимание, что мы установили выравнивание текста. Это просто указывает программе GameMaker Studio 2, с чего начать
      рисовать текст относительно заданной позиции, и в данном случае мы хотим, чтобы текст был отцентрирован по оси x.
    Добавьте несколько экземпляров объекта в редактор комнаты, а затем нажмите кнопку Play  в верхней части IDE. Вы должны увидеть что-то вроде этого:
    
    Во всех примерах до сих пор мы рисовали спрайт, назначенный экземпляру, но это не всегда так. В событии draw можно нарисовать все, что угодно, независимо от назначенного спрайта. Чтобы проиллюстрировать
      этот момент, мы изменим имеющийся у нас код, удалив вызов draw_self() и заменив его функцией для рисования цветного эллипса, как показано ниже:
    
    draw_ellipse_colour(x - 50, y - 32, x + 50, y + 32, c_fuchsia, c_lime, false); draw_set_halign(fa_center);
       draw_text(x, y + 32, "Мое имя " + имя); draw_text(x, y + 48, "Мой номер " + string(number));
    Запустите проект снова, и вы должны увидеть следующее:
    
    Важно отметить, что даже если мы не рисуем назначенный спрайт, он все равно будет использоваться для обнаружения столкновений. Поэтому, хотя вы рисуете что-то одно, столкновения все равно будут рассчитываться на основе
      назначенного спрайта, как если бы он был размещен в комнате вместе с экземпляром, даже если он не виден. Это довольно удобно, так как позволяет рисовать разные спрайты, но сохранять единую маску столкновений на основе
      назначенного спрайта. Также обратите внимание, что вы все еще можете применять различные преобразования, такие как X/Y масштаб, и столкновения будут основываться на измененном размере, даже если ничего не будет нарисовано, чтобы показать это.
  
   
   
  Уровень графического интерфейса
  В начале страницы мы упоминали, что будем говорить о событии Draw GUI Event, а также о событии Draw Event, поэтому давайте рассмотрим их сейчас. Событие Draw GUI Event работает с так называемым  слоем GUI Layer,
    который представляет собой специальный слой рисунка фиксированной ширины и высоты, который рисуется поверх экземпляров в комнате. Слой GUI хорош тем, что  он не перемещается вместе с камерой комнаты, поэтому это идеальное место для добавления статичных элементов GUI.
    элементов, таких как очки, шкалы здоровья и другая информация, которую ваша игра должна передать пользователю. Более подробную информацию о слое GUI можно найти в разделе События рисо вания
    руководства.
  ПРИМЕЧАНИЕ: Комнаты могут быть больше, чем размер экрана, поэтому вы можете иметь большие уровни для перемещения игрока. Это означает, что в редакторе комнат (или в коде) вам нужно определить камеру , которая будет следовать за действием вашей
    игры. По сути, это способ настройки фиксированной области экрана для отображения различных частей большой комнаты в зависимости, например, от положения игрока в комнате, и он используется во многих играх. Вспомните, как вид всегда следует за
    главного героя в классических играх, таких как Mario или Zelda. Это делается с помощью камер. Для получения дополнительной информации см. раздел Свойства комнаты в разделе "Редактор комнат" руководства.
  Все следующие примеры будут использовать событие Draw GUI, поэтому вам нужно будет создать объект и добавить к нему это событие. Обратите внимание, что объекту не нужно назначать спрайт, так как мы не хотим рисовать что-либо по умолчанию,
    и нам не нужно, чтобы он обнаруживал столкновения. Подобные объекты, предназначенные только для рисования или управления определенными аспектами игры, часто называют объектами-контроллерами. Также обратите внимание, что мы будем использовать один и тот же объект для
    во всех примерах, поэтому мы рекомендуем вам проходить их один за другим (хотя это не является строго необходимым).
   Текст рисунка
  
    При рисовании на слое GUI левый верхний угол является исходным положением, справа - +X, внизу - +Y. Это делает позиционирование текста и графики очень простым, как вы увидите в этом примере. Все, что мы собираемся здесь сделать, это нарисовать значение
      которое представляет собой результат игрока, поэтому в нашем объекте нам нужно добавить событие Create Event, чтобы инициализировать переменную для хранения этого значения, как показано ниже:
    
    player_score = 0;
    Мы также хотим добавить к объекту событие Keyboard Down <Space>, поскольку мы будем использовать его для увеличения счета каждый раз, когда вы нажимаете клавишу Space.
    
    В этом случае добавьте следующее:
    
    var _val = irandom(100); player_score = player_score + _val;
    Наконец, давайте нарисуем значение оценки в событии Draw GUI, вот так:
    В этом случае добавьте следующее:
    
    draw_set_halign(fa_left); draw_set_colour(c_yellow);
       draw_text(32, 32, "SCORE:"); draw_set_colour(c_white);
       var _str = string(player_score); draw_text_transformed(32, 48, _str, 2, 2, 0);
    Вы заметите, как мы использовали жестко заданные (или фиксированные) значения для x/y позиции рисуемого текста, поскольку нам не нужно, чтобы он был относительно какого-либо экземпляра, так как мы рисуем
      на слое графического интерфейса. Мы также использовали функцию "set color", чтобы изменить цвет текста, а также функцию "transformed", чтобы сделать фактическое значение очков больше.
      текстовых элементов в ваших собственных играх.
    Добавьте один экземпляр этого объекта в комнату, а затем нажмите кнопку Play  . Когда игра запустится, нажмите и отпустите клавишу <Space>, и вы увидите, что значение счета увеличивается.
    
     
  
  Рисование спрайтов
  
    В этом примере мы будем использовать слой GUI для рисования спрайтов. Самое очевидное применение для этого - нарисовать жизни игроков, поэтому давайте сделаем именно это! Для этого примера вам понадобится спрайт размером 64x64 пикселя.
      - но он не должен быть назначен объекту, так как мы будем рисовать его сами.
    Для начала нам нужно добавить несколько новых переменных к объекту в событии Create (если вы делали предыдущий пример, добавьте следующие переменные ниже тех, что уже есть):
    
    player_lives = 3; gui_w = display_get_gui_width();
    В этом коде мы инициализируем переменную для жизней игрока, но мы также создаем переменную для хранения ширины слоя GUI, чтобы мы могли правильно расположить все относительно правой части экрана. Мы могли бы просто жестко ввести значение в код
      и использовать его, но это будет означать, что если мы изменим размер комнаты или добавим камеры и т.д., то нам придется пройтись по коду и изменить значение везде. Использование display_get_gui_width() функция
      вместо этого означает, что нам не нужно беспокоиться о любых будущих изменениях такого рода, поскольку код будет автоматически адаптироваться к любому размеру слоя GUI.
    Далее мы хотим добавить к объекту событие Keyboard Pressed <Enter> Event, поскольку мы будем использовать его для изменения количества жизней при каждом нажатии клавиши Enter:
    
    В этом случае добавьте следующее:
    
    player_lives = player_lives -1; if player_lives < 0 { player_lives = 3; }
    Наконец, нам нужно нарисовать спрайты на дисплее. Для этого мы будем использовать цикл " for" (информация об использовании GML здесь и для DnD™ 
     здесь), а также переменную GUI width, чтобы расположить все в правом верхнем углу экрана. Итак, добавьте это в событие Draw Gui Event (после всех других действий, которые оно может
      из предыдущих примеров):
    
    for (var i = 0; i < player_lives; i += 1;) { var _xx = gui_w - 48 - (i * 70); draw_sprite(spr_Heart, 0, _xx, 48); }
    Если вы еще не добавили экземпляр этого объекта в комнату, добавьте его сейчас (только один!), а затем нажмите кнопку Play . После запуска игры нажимайте клавишу <Enter> несколько раз, чтобы увидеть, как меняются жизни.
    
    Прежде чем оставить этот пример, поэкспериментируйте с количеством жизней и посмотрите, что получится. Сейчас оно установлено на 3, но измените событие Create и событие Key Pressed, чтобы установить значение на 5, или 10... если вы все сделали правильно, то код должен адаптироваться и отрисовать их все.
      правильно, то код должен адаптироваться и нарисовать их всех правильно!
     
  
  Рисование панели здоровья
  
    В этом последнем примере рассматривается рисование панели здоровья на слое GUI. Это можно сделать разными способами, но в GameMaker Studio 2 есть встроенная функция, специально предназначенная для создания healthbar'ов, поэтому мы будем использовать именно ее.
      вы можете создать свои собственные, используя спрайты или фигуры. Для начала, как и раньше, нам нужно инициализировать переменную для хранения значения здоровья, поэтому добавьте следующий DnD™или GML в событие Create объекта (после любого другого кода, который уже может быть там).
      который уже может быть там):
    
    здоровье игрока = 100;
    Мы хотим использовать клавиши со стрелками для изменения значения здоровья вверх или вниз в зависимости от того, какая клавиша со стрелкой нажата, и мы можем сделать это, добавив два события Keyboard Pressed <Arrow>, однако, вероятно, проще использовать событие Step Event и некоторый код для проверки наличия клавиш, поэтому давайте добавим событие Step Event сейчас с помощью следующего DnD™ или GML:
    
    if keyboard_check(vk_up) { if player_health < 100 { player_health = player_health + 1; }  }  if keyboard_check(vk_down) { if player_health > 0 { player_health = player_health - 1; }  }
    После этого мы можем приступить к рисованию панели здоровья, что делается в событии Draw GUI, добавляя следующее (после всего остального, что уже есть):
    
    var _xx = gui_w / 2; draw_healthbar(_xx - 50, 24, _xx + 50, 40, player_health, c_black, c_white, c_red, c_lime, 0, true, true);
    Добавьте экземпляр этого объекта в комнату, если вы еще не сделали этого (только один!), а затем нажмите кнопку Play . Когда игра будет
      нажмите несколько раз на клавиши <Up Arrow> и <Down Arrow>, чтобы увидеть, как меняется здоровье.
    
  
   
  Мы надеемся, что после выполнения этих примеров у вас появится больше уверенности при использовании GameMaker Studio 2 и больше понимания того, как все это работает. В следующем разделе мы рассмотрим, как заставить нарисованные вами предметы перемещаться по комнате.
    а также принимать пользовательский ввод и реагировать на него.
   
   
   
  
    
      
        Назад: Указатель
        Следующее: Движение и управление
      
    
    © Copyright YoYo Games Ltd. 2021 Все права защищены
  
  
  

